diff --git configure configure
index a9ba7c8..cdf2ef9 100755
--- configure
+++ configure
@@ -7815,12 +7815,12 @@ if [ "$CFG_GUI" = "no" ]; then
     canBuildWebKit="no"
 fi
 
-if [ "$CFG_SHARED" = "no" ]; then
-    echo
-    echo "WARNING: Using static linking will disable the WebKit module."
-    echo
-    canBuildWebKit="no"
-fi
+#if [ "$CFG_SHARED" = "no" ]; then
+   # echo
+   # echo "WARNING: Using static linking will disable the WebKit module."
+   # echo
+   # canBuildWebKit="no"
+#fi
 
 CFG_CONCURRENT="yes"
 if [ "$canBuildQtConcurrent" = "no" ]; then
diff --git mkspecs/win32-msvc2008/qmake.conf mkspecs/win32-msvc2008/qmake.conf
index 5c31cda..b8631a8 100644
--- mkspecs/win32-msvc2008/qmake.conf
+++ mkspecs/win32-msvc2008/qmake.conf
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git mkspecs/win32-msvc2010/qmake.conf mkspecs/win32-msvc2010/qmake.conf
index 9e5711c..356d8b1 100644
--- mkspecs/win32-msvc2010/qmake.conf
+++ mkspecs/win32-msvc2010/qmake.conf
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git mkspecs/win32-msvc2012/qmake.conf mkspecs/win32-msvc2012/qmake.conf
index 875978b..963dcb2 100644
--- mkspecs/win32-msvc2012/qmake.conf
+++ mkspecs/win32-msvc2012/qmake.conf
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git mkspecs/win32-msvc2013/qmake.conf mkspecs/win32-msvc2013/qmake.conf
index 3ebb1da..48f1867 100644
--- mkspecs/win32-msvc2013/qmake.conf
+++ mkspecs/win32-msvc2013/qmake.conf
@@ -16,7 +16,7 @@ QMAKE_LEX               = flex
 QMAKE_LEXFLAGS          =
 QMAKE_YACC              = byacc
 QMAKE_YACCFLAGS         = -d
-QMAKE_CFLAGS            = -nologo -Zm200 -Zc:wchar_t- -FS
+QMAKE_CFLAGS            = -nologo -Zm200 -Zc:wchar_t- -FS -wd"4099"
 QMAKE_CFLAGS_WARN_ON    = -W3
 QMAKE_CFLAGS_WARN_OFF   = -W0
 QMAKE_CFLAGS_RELEASE    = -O2 -MD
@@ -28,7 +28,7 @@ QMAKE_CFLAGS_MP         = -MP
 
 QMAKE_CXX               = $$QMAKE_CC
 QMAKE_CXXFLAGS          = $$QMAKE_CFLAGS
-QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON -w34100 -w34189
+QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON
 QMAKE_CXXFLAGS_WARN_OFF = $$QMAKE_CFLAGS_WARN_OFF
 QMAKE_CXXFLAGS_RELEASE  = $$QMAKE_CFLAGS_RELEASE
 QMAKE_CXXFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git src/3rdparty/harfbuzz/src/harfbuzz-thai.c src/3rdparty/harfbuzz/src/harfbuzz-thai.c
index 3c0ffe8..039394a 100644
--- src/3rdparty/harfbuzz/src/harfbuzz-thai.c
+++ src/3rdparty/harfbuzz/src/harfbuzz-thai.c
@@ -53,12 +53,14 @@ static th_render_cell_win_def th_render_cell_win = 0;
 static th_render_cell_mac_def th_render_cell_mac = 0;
 
 static int init_libthai() {
-    if (!th_brk || !th_next_cell || !th_render_cell_tis || !th_render_cell_win || !th_render_cell_mac) {
+    static HB_Bool initialized = false;
+    if (!initialized && (!th_brk || !th_next_cell || !th_render_cell_tis || !th_render_cell_win || !th_render_cell_mac)) {
         th_brk = (th_brk_def) HB_Library_Resolve("thai", (int)LIBTHAI_MAJOR, "th_brk");
         th_next_cell = (th_next_cell_def)HB_Library_Resolve("thai", LIBTHAI_MAJOR, "th_next_cell");
         th_render_cell_tis = (th_render_cell_tis_def) HB_Library_Resolve("thai", (int)LIBTHAI_MAJOR, "th_render_cell_tis");
         th_render_cell_win = (th_render_cell_win_def) HB_Library_Resolve("thai", (int)LIBTHAI_MAJOR, "th_render_cell_win");
         th_render_cell_mac = (th_render_cell_mac_def) HB_Library_Resolve("thai", (int)LIBTHAI_MAJOR, "th_render_cell_mac");
+        initialized = true;
     }
     if (th_brk && th_next_cell && th_render_cell_tis && th_render_cell_win && th_render_cell_mac)
         return 1;
diff --git src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri
index d8290cf..bbec4c2 100644
--- src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri
+++ src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri
@@ -53,7 +53,7 @@ symbian {
     INCLUDEPATH *= $$MW_LAYER_SYSTEMINCLUDE
 }
 
-win32-*: DEFINES += _HAS_TR1=0
+win32-msvc200*: DEFINES += _HAS_TR1=0
 
 DEFINES += BUILDING_JavaScriptCore BUILDING_WTF
 
diff --git src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro
index a109179..146cb2d 100644
--- src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro
+++ src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro
@@ -217,6 +217,12 @@ symbian: {
     QMAKE_CXXFLAGS.ARMCC += -OTime -O3
 }
 
+static {
+  !isEmpty(INSTALL_LIBS): target.path = $$INSTALL_LIBS
+  else: target.path = $$[QT_INSTALL_LIBS]
+  INSTALLS += target
+}
+
 lessThan(QT_GCC_MAJOR_VERSION, 5) {
     # GCC 4.5 and before
     lessThan(QT_GCC_MINOR_VERSION, 6) {
diff --git src/3rdparty/webkit/Source/JavaScriptCore/wtf/HashSet.h src/3rdparty/webkit/Source/JavaScriptCore/wtf/HashSet.h
index 82245f3..52b9f22 100644
--- src/3rdparty/webkit/Source/JavaScriptCore/wtf/HashSet.h
+++ src/3rdparty/webkit/Source/JavaScriptCore/wtf/HashSet.h
@@ -92,6 +92,14 @@ namespace WTF {
         friend void deleteAllValues<>(const HashSet&);
         friend void fastDeleteAllValues<>(const HashSet&);
 
+#if COMPILER(MSVC) && _MSC_VER >= 1700
+        // MSVC2012/MSVC2013 has trouble constructing a HashTableConstIteratorAdapter from a
+        // HashTableIterator despite the existence of a const_iterator cast method on the latter class.
+        pair<iterator, bool> iterator_const_cast(const pair<typename HashTableType::iterator, bool>& p)
+        {
+            return make_pair(iterator(HashTableType::const_iterator(p.first)), p.second);
+        }
+#endif
         HashTableType m_impl;
     };
 
@@ -177,7 +185,11 @@ namespace WTF {
     template<typename T, typename U, typename V>
     inline pair<typename HashSet<T, U, V>::iterator, bool> HashSet<T, U, V>::add(const ValueType& value)
     {
+#if COMPILER(MSVC) && _MSC_VER >= 1700
+        return iterator_const_cast(m_impl.add(value));
+#else
         return m_impl.add(value);
+#endif
     }
 
     template<typename Value, typename HashFunctions, typename Traits>
@@ -186,7 +198,11 @@ namespace WTF {
     HashSet<Value, HashFunctions, Traits>::add(const T& value)
     {
         typedef HashSetTranslatorAdapter<ValueType, ValueTraits, T, HashTranslator> Adapter;
+#if COMPILER(MSVC) && _MSC_VER >= 1700
+        return iterator_const_cast(m_impl.template addPassingHashCode<T, T, Adapter>(value, value));
+#else
         return m_impl.template addPassingHashCode<T, T, Adapter>(value, value);
+#endif
     }
 
     template<typename T, typename U, typename V>
diff --git src/3rdparty/webkit/Source/JavaScriptCore/wtf/MathExtras.h src/3rdparty/webkit/Source/JavaScriptCore/wtf/MathExtras.h
index b66c6f5..4fbfa88 100644
--- src/3rdparty/webkit/Source/JavaScriptCore/wtf/MathExtras.h
+++ src/3rdparty/webkit/Source/JavaScriptCore/wtf/MathExtras.h
@@ -110,7 +110,7 @@ inline bool signbit(double x) { struct ieee_double *p = (struct ieee_double *)&x
 
 #endif
 
-#if COMPILER(MSVC) || (COMPILER(RVCT) && !(RVCT_VERSION_AT_LEAST(3, 0, 0, 0)))
+#if (COMPILER(MSVC) && _MSC_VER < 1800) || (COMPILER(RVCT) && !(RVCT_VERSION_AT_LEAST(3, 0, 0, 0)))
 
 // We must not do 'num + 0.5' or 'num - 0.5' because they can cause precision loss.
 static double round(double num)
@@ -135,7 +135,7 @@ inline double trunc(double num) { return num > 0 ? floor(num) : ceil(num); }
 
 #endif
 
-#if COMPILER(MSVC)
+#if COMPILER(MSVC) && _MSC_VER < 1800
 // The 64bit version of abs() is already defined in stdlib.h which comes with VC10
 #if COMPILER(MSVC9_OR_LOWER)
 inline long long abs(long long num) { return _abs64(num); }
diff --git src/3rdparty/webkit/Source/WebCore/WebCore.pri src/3rdparty/webkit/Source/WebCore/WebCore.pri
index 6ea37fd..db229a4 100644
--- src/3rdparty/webkit/Source/WebCore/WebCore.pri
+++ src/3rdparty/webkit/Source/WebCore/WebCore.pri
@@ -170,6 +170,10 @@ contains(DEFINES, ENABLE_XSLT=1) {
     QT *= xmlpatterns
 }
 
+contains(DEFINES, ENABLE_ZLIB=1) {
+    include($$QT_SOURCE_TREE/src/3rdparty/zlib_dependency.pri)
+}
+
 contains(DEFINES, ENABLE_SQLITE=1) {
     !system-sqlite:exists( $${SQLITE3SRCDIR}/sqlite3.c ) {
             INCLUDEPATH += $${SQLITE3SRCDIR}
diff --git src/3rdparty/webkit/Source/WebCore/WebCore.pro src/3rdparty/webkit/Source/WebCore/WebCore.pro
index a0d7d5d..33c2d70 100644
--- src/3rdparty/webkit/Source/WebCore/WebCore.pro
+++ src/3rdparty/webkit/Source/WebCore/WebCore.pro
@@ -16,7 +16,6 @@ CONFIG += staticlib
 DESTDIR = $$WEBCORE_DESTDIR
 
 DEFINES += BUILDING_WEBKIT
-DEFINES += QT_MAKEDLL
 
 contains(DEFINES, WTF_USE_QT_MOBILE_THEME=1) {
     DEFINES += ENABLE_NO_LISTBOX_RENDERING=1
@@ -989,6 +988,7 @@ SOURCES += \
     platform/graphics/PathTraversalState.cpp \
     platform/graphics/Pattern.cpp \
     platform/graphics/RoundedIntRect.cpp \
+    platform/graphics/WOFFFileFormat.cpp \
     platform/graphics/SegmentedFontData.cpp \
     platform/graphics/ShadowBlur.cpp \
     platform/graphics/SVGGlyph.cpp \
@@ -1959,6 +1959,7 @@ HEADERS += \
     platform/graphics/PathTraversalState.h \
     platform/graphics/Pattern.h \
     platform/graphics/RoundedIntRect.h \
+    platform/graphics/WOFFFileFormat.h \
     platform/graphics/qt/FontCustomPlatformData.h \
     platform/graphics/qt/ImageDecoderQt.h \
     platform/graphics/qt/StillImageQt.h \
@@ -3464,7 +3465,7 @@ contains(DEFINES, ENABLE_WEBGL=1) {
         INCLUDEPATH += $$PWD/platform/graphics/gpu
 }
 
-win32:!win32-g++*:contains(QMAKE_HOST.arch, x86_64):{
+win32:!win32-g++*:contains(QMAKE_TARGET.arch, x86_64):{
     asm_compiler.commands = ml64 /c
     asm_compiler.commands +=  /Fo ${QMAKE_FILE_OUT} ${QMAKE_FILE_IN}
     asm_compiler.output = ${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${first(QMAKE_EXT_OBJ)}
@@ -3476,7 +3477,7 @@ win32:!win32-g++*:contains(QMAKE_HOST.arch, x86_64):{
 
     ASM_SOURCES += \
         plugins/win/PaintHooks.asm
-   if(win32-msvc2005|win32-msvc2008):equals(TEMPLATE_PREFIX, "vc") {
+   if(win32-msvc*):equals(TEMPLATE_PREFIX, "vc") {
         SOURCES += \
             plugins/win/PaintHooks.asm
    }
diff --git src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
index 08626dd..4fb0fee 100644
--- src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
+++ src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
@@ -1245,6 +1245,8 @@ PassRefPtr<CSSValue> CSSComputedStyleDeclaration::getPropertyCSSValue(int proper
         case CSSPropertyOpacity:
             return primitiveValueCache->createValue(style->opacity(), CSSPrimitiveValue::CSS_NUMBER);
         case CSSPropertyOrphans:
+            if (style->hasAutoOrphans())
+                return primitiveValueCache->createIdentifierValue(CSSValueAuto);
             return primitiveValueCache->createValue(style->orphans(), CSSPrimitiveValue::CSS_NUMBER);
         case CSSPropertyOutlineColor:
             return m_allowVisitedStyle ? primitiveValueCache->createColorValue(style->visitedDependentColor(CSSPropertyOutlineColor).rgb()) : currentColorOrValidColor(style.get(), style->outlineColor());
@@ -1383,6 +1385,8 @@ PassRefPtr<CSSValue> CSSComputedStyleDeclaration::getPropertyCSSValue(int proper
         case CSSPropertyWhiteSpace:
             return primitiveValueCache->createValue(style->whiteSpace());
         case CSSPropertyWidows:
+            if (style->hasAutoWidows())
+                return primitiveValueCache->createIdentifierValue(CSSValueAuto);
             return primitiveValueCache->createValue(style->widows(), CSSPrimitiveValue::CSS_NUMBER);
         case CSSPropertyWidth:
             if (renderer)
diff --git src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp
index b0f7365..f51a25a 100644
--- src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp
+++ src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp
@@ -44,6 +44,10 @@
 #include "SVGURIReference.h"
 #endif
 
+#if PLATFORM(QT)
+#include <QFontInfo>
+#endif
+
 namespace WebCore {
 
 CSSFontFaceSource::CSSFontFaceSource(const String& str, CachedFont* font)
diff --git src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp
index 8024afa..9edf17f 100644
--- src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp
+++ src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp
@@ -108,94 +108,65 @@ void CSSFontSelector::addFontFaceRule(const CSSFontFaceRule* fontFaceRule)
     unsigned traitsMask = 0;
 
     if (RefPtr<CSSValue> fontStyle = style->getPropertyCSSValue(CSSPropertyFontStyle)) {
-        if (fontStyle->isPrimitiveValue()) {
-            RefPtr<CSSValueList> list = CSSValueList::createCommaSeparated();
-            list->append(fontStyle);
-            fontStyle = list;
-        } else if (!fontStyle->isValueList())
-            return;
-
-        CSSValueList* styleList = static_cast<CSSValueList*>(fontStyle.get());
-        unsigned numStyles = styleList->length();
-        if (!numStyles)
+        if (!fontStyle->isPrimitiveValue())
             return;
 
-        for (unsigned i = 0; i < numStyles; ++i) {
-            switch (static_cast<CSSPrimitiveValue*>(styleList->itemWithoutBoundsCheck(i))->getIdent()) {
-                case CSSValueAll:
-                    traitsMask |= FontStyleMask;
-                    break;
-                case CSSValueNormal:
-                    traitsMask |= FontStyleNormalMask;
-                    break;
-                case CSSValueItalic:
-                case CSSValueOblique:
-                    traitsMask |= FontStyleItalicMask;
-                    break;
-                default:
-                    break;
-            }
+        switch (static_cast<CSSPrimitiveValue*>(fontStyle.get())->getIdent()) {
+        case CSSValueNormal:
+            traitsMask |= FontStyleNormalMask;
+            break;
+        case CSSValueItalic:
+        case CSSValueOblique:
+            traitsMask |= FontStyleItalicMask;
+            break;
+        default:
+            break;
         }
     } else
-        traitsMask |= FontStyleMask;
+        traitsMask |= FontStyleNormalMask;
 
     if (RefPtr<CSSValue> fontWeight = style->getPropertyCSSValue(CSSPropertyFontWeight)) {
-        if (fontWeight->isPrimitiveValue()) {
-            RefPtr<CSSValueList> list = CSSValueList::createCommaSeparated();
-            list->append(fontWeight);
-            fontWeight = list;
-        } else if (!fontWeight->isValueList())
+        if (!fontWeight->isPrimitiveValue())
             return;
 
-        CSSValueList* weightList = static_cast<CSSValueList*>(fontWeight.get());
-        unsigned numWeights = weightList->length();
-        if (!numWeights)
-            return;
-
-        for (unsigned i = 0; i < numWeights; ++i) {
-            switch (static_cast<CSSPrimitiveValue*>(weightList->itemWithoutBoundsCheck(i))->getIdent()) {
-                case CSSValueAll:
-                    traitsMask |= FontWeightMask;
-                    break;
-                case CSSValueBolder:
-                case CSSValueBold:
-                case CSSValue700:
-                    traitsMask |= FontWeight700Mask;
-                    break;
-                case CSSValueNormal:
-                case CSSValue400:
-                    traitsMask |= FontWeight400Mask;
-                    break;
-                case CSSValue900:
-                    traitsMask |= FontWeight900Mask;
-                    break;
-                case CSSValue800:
-                    traitsMask |= FontWeight800Mask;
-                    break;
-                case CSSValue600:
-                    traitsMask |= FontWeight600Mask;
-                    break;
-                case CSSValue500:
-                    traitsMask |= FontWeight500Mask;
-                    break;
-                case CSSValue300:
-                    traitsMask |= FontWeight300Mask;
-                    break;
-                case CSSValueLighter:
-                case CSSValue200:
-                    traitsMask |= FontWeight200Mask;
-                    break;
-                case CSSValue100:
-                    traitsMask |= FontWeight100Mask;
-                    break;
-                default:
-                    break;
-            }
+        switch (static_cast<CSSPrimitiveValue*>(fontWeight.get())->getIdent()) {
+        case CSSValueBold:
+        case CSSValue700:
+            traitsMask |= FontWeight700Mask;
+            break;
+        case CSSValueNormal:
+        case CSSValue400:
+            traitsMask |= FontWeight400Mask;
+            break;
+        case CSSValue900:
+            traitsMask |= FontWeight900Mask;
+            break;
+        case CSSValue800:
+            traitsMask |= FontWeight800Mask;
+            break;
+        case CSSValue600:
+            traitsMask |= FontWeight600Mask;
+            break;
+        case CSSValue500:
+            traitsMask |= FontWeight500Mask;
+            break;
+        case CSSValue300:
+            traitsMask |= FontWeight300Mask;
+            break;
+        case CSSValue200:
+            traitsMask |= FontWeight200Mask;
+            break;
+        case CSSValue100:
+            traitsMask |= FontWeight100Mask;
+            break;
+        default:
+            break;
         }
     } else
-        traitsMask |= FontWeightMask;
+        traitsMask |= FontWeight400Mask;
 
     if (RefPtr<CSSValue> fontVariant = style->getPropertyCSSValue(CSSPropertyFontVariant)) {
+        // font-variant descriptor can be a value list
         if (fontVariant->isPrimitiveValue()) {
             RefPtr<CSSValueList> list = CSSValueList::createCommaSeparated();
             list->append(fontVariant);
@@ -210,9 +181,6 @@ void CSSFontSelector::addFontFaceRule(const CSSFontFaceRule* fontFaceRule)
 
         for (unsigned i = 0; i < numVariants; ++i) {
             switch (static_cast<CSSPrimitiveValue*>(variantList->itemWithoutBoundsCheck(i))->getIdent()) {
-                case CSSValueAll:
-                    traitsMask |= FontVariantMask;
-                    break;
                 case CSSValueNormal:
                     traitsMask |= FontVariantNormalMask;
                     break;
@@ -420,6 +388,7 @@ static inline bool compareFontFaces(CSSFontFace* first, CSSFontFace* second)
     if (firstHasDesiredVariant != secondHasDesiredVariant)
         return firstHasDesiredVariant;
 
+    // We need to check font-variant css property for CSS2.1 compatibility.
     if ((desiredTraitsMaskForComparison & FontVariantSmallCapsMask) && !first->isLocalFallback() && !second->isLocalFallback()) {
         // Prefer a font that has indicated that it can only support small-caps to a font that claims to support
         // all variants.  The specialized font is more likely to be true small-caps and not require synthesis.
@@ -449,12 +418,11 @@ static inline bool compareFontFaces(CSSFontFace* first, CSSFontFace* second)
     if (firstTraitsMask & desiredTraitsMaskForComparison & FontWeightMask)
         return true;
 
-    // http://www.w3.org/TR/2002/WD-css3-webfonts-20020802/#q46 says: "If there are fewer then 9 weights in the family, the default algorithm
-    // for filling the "holes" is as follows. If '500' is unassigned, it will be assigned the same font as '400'. If any of the values '600',
-    // '700', '800', or '900' remains unassigned, they are assigned to the same face as the next darker assigned keyword, if any, or the next
-    // lighter one otherwise. If any of '300', '200', or '100' remains unassigned, it is assigned to the next lighter assigned keyword, if any,
-    // or the next darker otherwise."
-    // For '400', we made up our own rule (which then '500' follows).
+    // http://www.w3.org/TR/2011/WD-css3-fonts-20111004/#font-matching-algorithm says :
+    //   - If the desired weight is less than 400, weights below the desired weight are checked in descending order followed by weights above the desired weight in ascending order until a match is found.
+    //   - If the desired weight is greater than 500, weights above the desired weight are checked in ascending order followed by weights below the desired weight in descending order until a match is found.
+    //   - If the desired weight is 400, 500 is checked first and then the rule for desired weights less than 400 is used.
+    //   - If the desired weight is 500, 400 is checked first and then the rule for desired weights less than 400 is used.
 
     static const unsigned fallbackRuleSets = 9;
     static const unsigned rulesPerSet = 8;
@@ -462,8 +430,8 @@ static inline bool compareFontFaces(CSSFontFace* first, CSSFontFace* second)
         { FontWeight200Mask, FontWeight300Mask, FontWeight400Mask, FontWeight500Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
         { FontWeight100Mask, FontWeight300Mask, FontWeight400Mask, FontWeight500Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
         { FontWeight200Mask, FontWeight100Mask, FontWeight400Mask, FontWeight500Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
-        { FontWeight500Mask, FontWeight300Mask, FontWeight600Mask, FontWeight200Mask, FontWeight700Mask, FontWeight100Mask, FontWeight800Mask, FontWeight900Mask },
-        { FontWeight400Mask, FontWeight300Mask, FontWeight600Mask, FontWeight200Mask, FontWeight700Mask, FontWeight100Mask, FontWeight800Mask, FontWeight900Mask },
+        { FontWeight500Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
+        { FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
         { FontWeight700Mask, FontWeight800Mask, FontWeight900Mask, FontWeight500Mask, FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask },
         { FontWeight800Mask, FontWeight900Mask, FontWeight600Mask, FontWeight500Mask, FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask },
         { FontWeight900Mask, FontWeight700Mask, FontWeight600Mask, FontWeight500Mask, FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask },
diff --git src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp
index 641ae05..ff7cd0e 100644
--- src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp
+++ src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp
@@ -1241,7 +1241,9 @@ bool CSSParser::parseValue(int propId, bool important)
         break;
 
     case CSSPropertyFontStyle:           // normal | italic | oblique | inherit
-        return parseFontStyle(important);
+        if (id == CSSValueNormal || id == CSSValueItalic || id == CSSValueOblique)
+            validPrimitive = true;
+        break;
 
     case CSSPropertyFontVariant:         // normal | small-caps | inherit
         return parseFontVariant(important);
@@ -1291,10 +1293,12 @@ bool CSSParser::parseValue(int propId, bool important)
             break;
         }
         /* nobreak */
-    case CSSPropertyOrphans:              // <integer> | inherit
-    case CSSPropertyWidows:               // <integer> | inherit
-        // ### not supported later on
-        validPrimitive = (!id && validUnit(value, FInteger, false));
+    case CSSPropertyOrphans:              // <integer> | inherit | auto (We've added support for auto for backwards compatibility)
+    case CSSPropertyWidows:               // <integer> | inherit | auto (Ditto)
+        if (id == CSSValueAuto)
+            validPrimitive = true;
+        else
+            validPrimitive = (!id && validUnit(value, FInteger, false));
         break;
 
     case CSSPropertyLineHeight:          // normal | <number> | <length> | <percentage> | inherit
@@ -3760,53 +3764,6 @@ PassRefPtr<CSSValueList> CSSParser::parseFontFamily()
     return list.release();
 }
 
-bool CSSParser::parseFontStyle(bool important)
-{
-    RefPtr<CSSValueList> values;
-    if (m_valueList->size() > 1)
-        values = CSSValueList::createCommaSeparated();
-    CSSParserValue* val;
-    bool expectComma = false;
-    while ((val = m_valueList->current())) {
-        RefPtr<CSSPrimitiveValue> parsedValue;
-        if (!expectComma) {
-            expectComma = true;
-            if (val->id == CSSValueNormal || val->id == CSSValueItalic || val->id == CSSValueOblique)
-                parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-            else if (val->id == CSSValueAll && !values) {
-                // 'all' is only allowed in @font-face and with no other values. Make a value list to
-                // indicate that we are in the @font-face case.
-                values = CSSValueList::createCommaSeparated();
-                parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-            }
-        } else if (val->unit == CSSParserValue::Operator && val->iValue == ',') {
-            expectComma = false;
-            m_valueList->next();
-            continue;
-        }
-
-        if (!parsedValue)
-            return false;
-
-        m_valueList->next();
-
-        if (values)
-            values->append(parsedValue.release());
-        else {
-            addProperty(CSSPropertyFontStyle, parsedValue.release(), important);
-            return true;
-        }
-    }
-
-    if (values && values->length()) {
-        m_hasFontFaceOnlyValues = true;
-        addProperty(CSSPropertyFontStyle, values.release(), important);
-        return true;
-    }
-
-    return false;
-}
-
 bool CSSParser::parseFontVariant(bool important)
 {
     RefPtr<CSSValueList> values;
@@ -3856,51 +3813,19 @@ bool CSSParser::parseFontVariant(bool important)
 
 bool CSSParser::parseFontWeight(bool important)
 {
-    RefPtr<CSSValueList> values;
-    if (m_valueList->size() > 1)
-        values = CSSValueList::createCommaSeparated();
-    CSSParserValue* val;
-    bool expectComma = false;
-    while ((val = m_valueList->current())) {
-        RefPtr<CSSPrimitiveValue> parsedValue;
-        if (!expectComma) {
-            expectComma = true;
-            if (val->unit == CSSPrimitiveValue::CSS_IDENT) {
-                if (val->id >= CSSValueNormal && val->id <= CSSValue900)
-                    parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-                else if (val->id == CSSValueAll && !values) {
-                    // 'all' is only allowed in @font-face and with no other values. Make a value list to
-                    // indicate that we are in the @font-face case.
-                    values = CSSValueList::createCommaSeparated();
-                    parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-                }
-            } else if (validUnit(val, FInteger | FNonNeg, false)) {
-                int weight = static_cast<int>(val->fValue);
-                if (!(weight % 100) && weight >= 100 && weight <= 900)
-                    parsedValue = primitiveValueCache()->createIdentifierValue(CSSValue100 + weight / 100 - 1);
-            }
-        } else if (val->unit == CSSParserValue::Operator && val->iValue == ',') {
-            expectComma = false;
-            m_valueList->next();
-            continue;
-        }
-
-        if (!parsedValue)
-            return false;
-
-        m_valueList->next();
+    if (m_valueList->size() != 1)
+        return false;
 
-        if (values)
-            values->append(parsedValue.release());
-        else {
-            addProperty(CSSPropertyFontWeight, parsedValue.release(), important);
-            return true;
-        }
+    CSSParserValue* value = m_valueList->current();
+    if ((value->id >= CSSValueNormal) && (value->id <= CSSValue900)) {
+        addProperty(CSSPropertyFontWeight, primitiveValueCache()->createIdentifierValue(value->id), important);
+        return true;
     }
 
-    if (values && values->length()) {
-        m_hasFontFaceOnlyValues = true;
-        addProperty(CSSPropertyFontWeight, values.release(), important);
+    if (validUnit(value, FInteger | FNonNeg, false)) {
+        int weight = static_cast<int>(value->fValue);
+            if (!(weight % 100) && weight >= 100 && weight <= 900)
+                addProperty(CSSPropertyFontWeight, primitiveValueCache()->createIdentifierValue(CSSValue100 + weight / 100 - 1), important);
         return true;
     }
 
@@ -6339,7 +6264,7 @@ CSSRule* CSSParser::createFontFaceRule()
     for (unsigned i = 0; i < m_numParsedProperties; ++i) {
         CSSProperty* property = m_parsedProperties[i];
         int id = property->id();
-        if ((id == CSSPropertyFontWeight || id == CSSPropertyFontStyle || id == CSSPropertyFontVariant) && property->value()->isPrimitiveValue()) {
+        if (id == CSSPropertyFontVariant && property->value()->isPrimitiveValue()) {
             RefPtr<CSSValue> value = property->m_value.release();
             property->m_value = CSSValueList::createCommaSeparated();
             static_cast<CSSValueList*>(property->value())->append(value.release());
@@ -6466,7 +6391,7 @@ void CSSParser::deleteFontFaceOnlyValues()
     for (unsigned i = 0; i < m_numParsedProperties; ++i) {
         CSSProperty* property = m_parsedProperties[i];
         int id = property->id();
-        if ((id == CSSPropertyFontWeight || id == CSSPropertyFontStyle || id == CSSPropertyFontVariant) && property->value()->isValueList()) {
+        if (id == CSSPropertyFontVariant && property->value()->isValueList()) {
             delete property;
             deletedProperties++;
         } else if (deletedProperties)
diff --git src/3rdparty/webkit/Source/WebCore/css/CSSParser.h src/3rdparty/webkit/Source/WebCore/css/CSSParser.h
index 0524302..0b8b691 100644
--- src/3rdparty/webkit/Source/WebCore/css/CSSParser.h
+++ src/3rdparty/webkit/Source/WebCore/css/CSSParser.h
@@ -140,7 +140,6 @@ namespace WebCore {
 
         static bool parseColor(const String&, RGBA32& rgb, bool strict);
 
-        bool parseFontStyle(bool important);
         bool parseFontVariant(bool important);
         bool parseFontWeight(bool important);
         bool parseFontFaceSrc();
diff --git src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp
index 7bb30d3..44f5d08 100644
--- src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp
+++ src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp
@@ -4123,19 +4123,32 @@ void CSSStyleSelector::applyProperty(int id, CSSValue *value)
     }
     case CSSPropertyWidows:
     {
-        HANDLE_INHERIT_AND_INITIAL(widows, Widows)
-        if (!primitiveValue || primitiveValue->primitiveType() != CSSPrimitiveValue::CSS_NUMBER)
+        if (isInherit) {
+            if (m_parentStyle->hasAutoWidows())
+                m_style->setHasAutoWidows();
+            else
+                m_style->setWidows(m_parentStyle->widows());
             return;
-        m_style->setWidows(primitiveValue->getIntValue());
+        } else if (isInitial || primitiveValue->getIdent() == CSSValueAuto) {
+            m_style->setHasAutoWidows();
+            return;
+        }
+        m_style->setWidows(static_cast<short>(primitiveValue->getIntValue()));
         return;
     }
-        
     case CSSPropertyOrphans:
     {
-        HANDLE_INHERIT_AND_INITIAL(orphans, Orphans)
-        if (!primitiveValue || primitiveValue->primitiveType() != CSSPrimitiveValue::CSS_NUMBER)
+        if (isInherit) {
+            if (m_parentStyle->hasAutoOrphans())
+                m_style->setHasAutoOrphans();
+            else
+                m_style->setOrphans(m_parentStyle->widows());
             return;
-        m_style->setOrphans(primitiveValue->getIntValue());
+        } else if (isInitial || primitiveValue->getIdent() == CSSValueAuto) {
+            m_style->setHasAutoOrphans();
+            return;
+        }
+        m_style->setOrphans(static_cast<short>(primitiveValue->getIntValue()));
         return;
     }        
 
diff --git src/3rdparty/webkit/Source/WebCore/features.pri src/3rdparty/webkit/Source/WebCore/features.pri
index 612ed8a..ce8de52 100644
--- src/3rdparty/webkit/Source/WebCore/features.pri
+++ src/3rdparty/webkit/Source/WebCore/features.pri
@@ -45,6 +45,7 @@ contains(DEFINES, ENABLE_SINGLE_THREADED=1) {
 !contains(DEFINES, ENABLE_DIRECTORY_UPLOAD=.): DEFINES += ENABLE_DIRECTORY_UPLOAD=0
 !contains(DEFINES, ENABLE_FILE_SYSTEM=.): DEFINES += ENABLE_FILE_SYSTEM=0
 !contains(DEFINES, ENABLE_QUOTA=.): DEFINES += ENABLE_QUOTA=0 
+!contains(DEFINES, ENABLE_ZLIB=.): DEFINES += ENABLE_ZLIB=1
 
 # turn on SQLITE support if any of the dependent features are turned on
 !contains(DEFINES, ENABLE_SQLITE=.) {
diff --git src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp
index ef72fb7..54ff69c 100644
--- src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp
+++ src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp
@@ -1080,7 +1080,9 @@ void FrameView::adjustMediaTypeForPrinting(bool printing)
     if (printing) {
         if (m_mediaTypeWhenNotPrinting.isNull())
             m_mediaTypeWhenNotPrinting = mediaType();
-            setMediaType("print");
+
+        String mediaType = (m_frame && m_frame->settings())?m_frame->settings()->printingMediaType():"print";
+        setMediaType(mediaType);
     } else {
         if (!m_mediaTypeWhenNotPrinting.isNull())
             setMediaType(m_mediaTypeWhenNotPrinting);
diff --git src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp
index 660ad11..443e500 100644
--- src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp
+++ src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp
@@ -26,6 +26,7 @@
 #include "FrameView.h"
 #include "RenderLayer.h"
 #include "RenderView.h"
+#include "Settings.h"
 #include <wtf/text/StringConcatenate.h>
 
 namespace WebCore {
@@ -82,9 +83,16 @@ void PrintContext::computePageRects(const FloatRect& printRect, float headerHeig
     float pageWidth;
     float pageHeight;
     if (isHorizontal) {
-        float ratio = printRect.height() / printRect.width();
         pageWidth = view->docWidth();
-        pageHeight = floorf(pageWidth * ratio);
+        ///NOTE: if we do not reuse the previously set logical page height,
+        ///      we can end up with off-by-one errors in the page height,
+        ///      leading to rendering issues (e.g. rows overlap pagebreaks)
+        if (view->pageLogicalHeight() == 0) {
+            float ratio = printRect.height() / printRect.width();
+            pageHeight = floorf(pageWidth * ratio);
+        } else {
+            pageHeight = view->pageLogicalHeight();
+        }
     } else {
         float ratio = printRect.width() / printRect.height();
         pageHeight = view->docHeight();
@@ -182,11 +190,21 @@ void PrintContext::begin(float width, float height)
     // This function can be called multiple times to adjust printing parameters without going back to screen mode.
     m_isPrinting = true;
 
-    float minLayoutWidth = width * printingMinimumShrinkFactor;
-    float minLayoutHeight = height * printingMinimumShrinkFactor;
+    float minimumShrinkFactor = m_frame->settings() ? 
+        m_frame->settings()->printingMinimumShrinkFactor() : 0.0f;
+    float maximumShrinkFactor = m_frame->settings() ? 
+        m_frame->settings()->printingMaximumShrinkFactor() : 0.0f;
+
+    if (maximumShrinkFactor < minimumShrinkFactor || minimumShrinkFactor <= 0.0f) {
+        minimumShrinkFactor = printingMinimumShrinkFactor;
+        maximumShrinkFactor = printingMaximumShrinkFactor;
+    }
+    
+    float minLayoutWidth = width * minimumShrinkFactor;
+    float minLayoutHeight = height * minimumShrinkFactor;
 
     // This changes layout, so callers need to make sure that they don't paint to screen while in printing mode.
-    m_frame->setPrinting(true, FloatSize(minLayoutWidth, minLayoutHeight), printingMaximumShrinkFactor / printingMinimumShrinkFactor, Frame::AdjustViewSize);
+    m_frame->setPrinting(true, FloatSize(minLayoutWidth, minLayoutHeight), maximumShrinkFactor / minimumShrinkFactor, Frame::AdjustViewSize);
 }
 
 float PrintContext::computeAutomaticScaleFactor(const FloatSize& availablePaperSize)
diff --git src/3rdparty/webkit/Source/WebCore/page/PrintContext.h src/3rdparty/webkit/Source/WebCore/page/PrintContext.h
index aadff47..19f378e 100644
--- src/3rdparty/webkit/Source/WebCore/page/PrintContext.h
+++ src/3rdparty/webkit/Source/WebCore/page/PrintContext.h
@@ -83,6 +83,8 @@ public:
     // (pageSizeInPixels.height() + 1) * number-of-pages - 1
     static void spoolAllPagesWithBoundaries(Frame*, GraphicsContext&, const FloatSize& pageSizeInPixels);
 
+public:
+    const Vector<IntRect> & getPageRects() const {return m_pageRects;}
 protected:
     Frame* m_frame;
     Vector<IntRect> m_pageRects;
diff --git src/3rdparty/webkit/Source/WebCore/page/Settings.cpp src/3rdparty/webkit/Source/WebCore/page/Settings.cpp
index 2025bd0..5414246 100644
--- src/3rdparty/webkit/Source/WebCore/page/Settings.cpp
+++ src/3rdparty/webkit/Source/WebCore/page/Settings.cpp
@@ -87,6 +87,7 @@ static EditingBehaviorType editingBehaviorTypeForPlatform()
 
 Settings::Settings(Page* page)
     : m_page(page)
+    , m_printingMediaType("print")
     , m_editableLinkBehavior(EditableLinkDefaultBehavior)
     , m_textDirectionSubmenuInclusionBehavior(TextDirectionSubmenuAutomaticallyIncluded)
     , m_passwordEchoDurationInSeconds(1)
@@ -184,6 +185,8 @@ Settings::Settings(Page* page)
     , m_allowDisplayOfInsecureContent(true)
     , m_allowRunningOfInsecureContent(true)
     , m_passwordEchoEnabled(false)
+    , m_printingMinimumShrinkFactor(0.0)
+    , m_printingMaximumShrinkFactor(0.0)
 {
     // A Frame may not have been created yet, so we initialize the AtomicString 
     // hash before trying to use it.
@@ -569,6 +572,11 @@ void Settings::setApplicationChromeMode(bool mode)
     m_inApplicationChromeMode = mode;
 }
 
+void Settings::setPrintingMediaType(const String& type)
+{
+    m_printingMediaType = type;
+}
+
 void Settings::setOfflineWebApplicationCacheEnabled(bool enabled)
 {
     m_offlineWebApplicationCacheEnabled = enabled;
@@ -744,4 +752,15 @@ void Settings::setTiledBackingStoreEnabled(bool enabled)
 #endif
 }
 
+void Settings::setPrintingMinimumShrinkFactor(float printingMinimumShrinkFactor)
+{
+    m_printingMinimumShrinkFactor = printingMinimumShrinkFactor;
+}    
+
+void Settings::setPrintingMaximumShrinkFactor(float printingMaximumShrinkFactor)
+{
+    m_printingMaximumShrinkFactor = printingMaximumShrinkFactor;
+}    
+
+
 } // namespace WebCore
diff --git src/3rdparty/webkit/Source/WebCore/page/Settings.h src/3rdparty/webkit/Source/WebCore/page/Settings.h
index 1d2a138..d827693 100644
--- src/3rdparty/webkit/Source/WebCore/page/Settings.h
+++ src/3rdparty/webkit/Source/WebCore/page/Settings.h
@@ -258,6 +258,9 @@ namespace WebCore {
         void setApplicationChromeMode(bool);
         bool inApplicationChromeMode() const { return m_inApplicationChromeMode; }
 
+        void setPrintingMediaType(const String&);
+        const String& printingMediaType() const { return m_printingMediaType; }
+
         void setOfflineWebApplicationCacheEnabled(bool);
         bool offlineWebApplicationCacheEnabled() const { return m_offlineWebApplicationCacheEnabled; }
 
@@ -349,6 +352,12 @@ namespace WebCore {
         
         void setTiledBackingStoreEnabled(bool);
         bool tiledBackingStoreEnabled() const { return m_tiledBackingStoreEnabled; }
+	
+        void setPrintingMinimumShrinkFactor(float);
+        float printingMinimumShrinkFactor() const { return m_printingMinimumShrinkFactor; }
+	
+        void setPrintingMaximumShrinkFactor(float);
+        float printingMaximumShrinkFactor() const { return m_printingMaximumShrinkFactor; }
 
         void setPaginateDuringLayoutEnabled(bool flag) { m_paginateDuringLayoutEnabled = flag; }
         bool paginateDuringLayoutEnabled() const { return m_paginateDuringLayoutEnabled; }
@@ -419,6 +428,7 @@ namespace WebCore {
         String m_defaultTextEncodingName;
         String m_ftpDirectoryTemplatePath;
         String m_localStorageDatabasePath;
+        String m_printingMediaType;
         KURL m_userStyleSheetLocation;
         AtomicString m_standardFontFamily;
         AtomicString m_fixedFontFamily;
@@ -429,6 +439,8 @@ namespace WebCore {
         EditableLinkBehavior m_editableLinkBehavior;
         TextDirectionSubmenuInclusionBehavior m_textDirectionSubmenuInclusionBehavior;
         double m_passwordEchoDurationInSeconds;
+        float m_printingMinimumShrinkFactor;
+        float m_printingMaximumShrinkFactor;
         int m_minimumFontSize;
         int m_minimumLogicalFontSize;
         int m_defaultFontSize;
diff --git src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp
index 00a15e8..b04a8f9 100644
--- src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp
+++ src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp
@@ -656,6 +656,8 @@ void AnimationBase::ensurePropertyMap()
         gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyWebkitBorderHorizontalSpacing, &RenderStyle::horizontalBorderSpacing, &RenderStyle::setHorizontalBorderSpacing));
         gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyWebkitBorderVerticalSpacing, &RenderStyle::verticalBorderSpacing, &RenderStyle::setVerticalBorderSpacing));
         gPropertyWrappers->append(new PropertyWrapper<int>(CSSPropertyZIndex, &RenderStyle::zIndex, &RenderStyle::setZIndex));
+        gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyOrphans, &RenderStyle::orphans, &RenderStyle::setOrphans));
+        gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyWidows, &RenderStyle::widows, &RenderStyle::setWidows));
         gPropertyWrappers->append(new PropertyWrapper<Length>(CSSPropertyLineHeight, &RenderStyle::lineHeight, &RenderStyle::setLineHeight));
         gPropertyWrappers->append(new PropertyWrapper<int>(CSSPropertyOutlineOffset, &RenderStyle::outlineOffset, &RenderStyle::setOutlineOffset));
         gPropertyWrappers->append(new PropertyWrapper<unsigned short>(CSSPropertyOutlineWidth, &RenderStyle::outlineWidth, &RenderStyle::setOutlineWidth));
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp
index 31966d7..505abc8 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp
@@ -35,6 +35,7 @@
 #include <wtf/text/StringHash.h>
 
 #include <QFont>
+#include <QFontDatabase>
 #if HAVE(QRAWFONT)
 #include <QTextLayout>
 #endif
@@ -106,6 +107,10 @@ void FontCache::getTraitsInFamily(const AtomicString&, Vector<unsigned>&)
 
 FontPlatformData* FontCache::createFontPlatformData(const FontDescription& fontDescription, const AtomicString& familyName)
 {
+    QFontDatabase db;
+    if (!db.hasFamily(familyName))
+        return 0;
+
     return new FontPlatformData(fontDescription, familyName);
 }
 
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h
index 3996d22..d880f73 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h
@@ -43,9 +43,11 @@ public:
 
     // for use with QFontDatabase::addApplicationFont/removeApplicationFont
     int m_handle;
+    bool m_italic;
+    bool m_bold;
 
-    FontPlatformData fontPlatformData(int size, bool bold, bool italic, FontOrientation = Horizontal, TextOrientation = TextOrientationVerticalRight,
-                                      FontWidthVariant = RegularWidth, FontRenderingMode = NormalRenderingMode);
+    FontPlatformData fontPlatformData(int size, bool syntheticBold, bool syntheticItalic, FontOrientation = Horizontal, 
+        TextOrientation = TextOrientationVerticalRight, FontWidthVariant = RegularWidth, FontRenderingMode = NormalRenderingMode);
 
     static bool supportsFormat(const String&);
 };
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp
index 20f161a..0ce1563 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp
@@ -24,7 +24,9 @@
 
 #include "FontPlatformData.h"
 #include "SharedBuffer.h"
+#include "WOFFFileFormat.h"
 #include <QFontDatabase>
+#include <QMap>
 #include <QStringList>
 
 namespace WebCore {
@@ -34,36 +36,113 @@ FontCustomPlatformData::~FontCustomPlatformData()
     QFontDatabase::removeApplicationFont(m_handle);
 }
 
-FontPlatformData FontCustomPlatformData::fontPlatformData(int size, bool bold, bool italic, FontOrientation, TextOrientation, FontWidthVariant, FontRenderingMode)
+FontPlatformData FontCustomPlatformData::fontPlatformData(int size, bool syntheticBold, bool syntheticItalic, FontOrientation, TextOrientation, FontWidthVariant, FontRenderingMode)
 {
+    // Note that syntheticBold and syntheticItalic are only set by CSSFontSelector
+    // (the sole user of this class) if the markup has requested bold or italic
+    // (e.g. <i>text</i>) but the @font-face rule for the font does not specify support
+    // for it (e.g. @font-face { font-family: "font"; font-style: normal;).
+
     QFont font;
-    font.setFamily(QFontDatabase::applicationFontFamilies(m_handle)[0]);
+    QFontDatabase db;
+    
+    QString family = QFontDatabase::applicationFontFamilies(m_handle)[0];
+    font.setFamily(family);
     font.setPixelSize(size);
-    if (bold)
+    if (m_bold || syntheticBold)
         font.setWeight(QFont::Bold);
-    font.setItalic(italic);
+    font.setItalic(m_italic || syntheticItalic);
 
     return FontPlatformData(font);
 }
 
+static QMap<QString, QStringList> currentStyles(const QStringList& families, const QFontDatabase& db)
+{
+    QMap<QString, QStringList> styles;
+    for (int i = 0; i < families.size(); ++i)
+        styles[families.at(i)].append(db.styles(families.at(i)));
+    return styles;
+}
+
+static QStringList stylesAddedByFont(const QString& familyAdded, const QStringList& stylesAdded, const QMap<QString, QStringList>& styles)
+{
+    QStringList newStyles = stylesAdded;
+    for (int i = 0; i < styles[familyAdded].size(); ++i)
+        newStyles.removeAll(styles[familyAdded].at(i));
+    return newStyles;
+}
+
+static bool strictlyItalicAddedByFont(const QString& familyAdded, const QStringList& stylesAdded, const QFontDatabase& db)
+{
+    bool italic = false;
+    for (int i = 0; i < stylesAdded.size(); ++i) {
+        if (db.italic(familyAdded, stylesAdded.at(i))) {
+            italic = true;
+        } else if (!db.bold(familyAdded, stylesAdded.at(i)))
+            return false;
+    }
+    return italic;
+}
+
+static bool strictlyBoldAddedByFont(const QString& familyAdded, const QStringList& stylesAdded, const QFontDatabase& db)
+{
+    bool bold = false;
+    for (int i = 0; i < stylesAdded.size(); ++i) {
+        if (db.bold(familyAdded, stylesAdded.at(i))) {
+            bold = true;
+        } else if (!db.italic(familyAdded, stylesAdded.at(i)))
+            return false;
+    }
+    return bold;
+}
+
 FontCustomPlatformData* createFontCustomPlatformData(SharedBuffer* buffer)
 {
     ASSERT_ARG(buffer, buffer);
+    QFontDatabase db;
+
+    // The font families in the font database, and the styles in each,
+    // before we load the new font in buffer.
+    QStringList families = db.families();
+    QMap<QString, QStringList> styles = currentStyles(families, db);
+
+    RefPtr<SharedBuffer> sfntBuffer;
+    if (isWOFF(buffer)) {
+        Vector<char> sfnt;
+        if (!convertWOFFToSfnt(buffer, sfnt))
+            return 0;
+        sfntBuffer = SharedBuffer::adoptVector(sfnt);
+        buffer = sfntBuffer.get();
+    }
 
     int id = QFontDatabase::addApplicationFontFromData(QByteArray(buffer->data(), buffer->size()));
     if (id == -1)
         return 0;
 
+    QString familyAdded = QFontDatabase::applicationFontFamilies(id)[0];
+    QStringList stylesAdded = db.styles(QFontDatabase::applicationFontFamilies(id)[0]);
+
+    // If we already had the family of which this font is a member then
+    // get the styles it added to the family
+    if (families.contains(familyAdded))
+        stylesAdded = stylesAddedByFont(familyAdded, stylesAdded, styles);
+
     Q_ASSERT(QFontDatabase::applicationFontFamilies(id).size() > 0);
 
     FontCustomPlatformData *data = new FontCustomPlatformData;
     data->m_handle = id;
+
+    // If we have created a font that only has bold or italic styles (or both)
+    // then we need to respect it's style(s) when we pass it back as
+    // FontPlatformData above.
+    data->m_italic = strictlyItalicAddedByFont(familyAdded, stylesAdded, db);
+    data->m_bold = strictlyBoldAddedByFont(familyAdded, stylesAdded, db);
     return data;
 }
 
 bool FontCustomPlatformData::supportsFormat(const String& format)
 {
-    return equalIgnoringCase(format, "truetype") || equalIgnoringCase(format, "opentype");
+    return equalIgnoringCase(format, "truetype") || equalIgnoringCase(format, "opentype") || equalIgnoringCase(format, "woff");
 }
 
 }
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h
index 88fd627..efa9568 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h
@@ -36,6 +36,27 @@
 
 namespace WebCore {
 
+static inline QFont::Weight toQFontWeight(FontWeight fontWeight)
+{
+    switch (fontWeight) {
+    case FontWeight100:
+    case FontWeight200:
+        return QFont::Light; // QFont::Light == Weight of 25
+    case FontWeight600:
+        return QFont::DemiBold; // QFont::DemiBold == Weight of 63
+    case FontWeight700:
+    case FontWeight800:
+        return QFont::Bold; // QFont::Bold == Weight of 75
+    case FontWeight900:
+        return QFont::Black; // QFont::Black == Weight of 87
+    case FontWeight300:
+    case FontWeight400:
+    case FontWeight500:
+    default:
+        return QFont::Normal; // QFont::Normal == Weight of 50
+    }
+}
+
 class FontPlatformDataPrivate : public RefCounted<FontPlatformDataPrivate> {
     WTF_MAKE_NONCOPYABLE(FontPlatformDataPrivate); WTF_MAKE_FAST_ALLOCATED;
 public:
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp
index c348870..864bcab 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp
@@ -27,27 +27,6 @@
 
 namespace WebCore {
 
-static inline QFont::Weight toQFontWeight(FontWeight fontWeight)
-{
-    switch (fontWeight) {
-    case FontWeight100:
-    case FontWeight200:
-        return QFont::Light; // QFont::Light == Weight of 25
-    case FontWeight600:
-        return QFont::DemiBold; // QFont::DemiBold == Weight of 63
-    case FontWeight700:
-    case FontWeight800:
-        return QFont::Bold; // QFont::Bold == Weight of 75
-    case FontWeight900:
-        return QFont::Black; // QFont::Black == Weight of 87
-    case FontWeight300:
-    case FontWeight400:
-    case FontWeight500:
-    default:
-        return QFont::Normal; // QFont::Normal == Weight of 50
-    }
-}
-
 static inline bool isEmptyValue(const float size, const bool bold, const bool oblique)
 {
      // this is the empty value by definition of the trait FontDataCacheKeyTraits
@@ -73,7 +52,8 @@ FontPlatformData::FontPlatformData(const FontDescription& description, const Ato
     font.setLetterSpacing(QFont::AbsoluteSpacing, letterSpacing);
     const bool smallCaps = description.smallCaps();
     font.setCapitalization(smallCaps ? QFont::SmallCaps : QFont::MixedCase);
-    font.setStyleStrategy(QFont::ForceIntegerMetrics);
+    // Commented out to work around webkit bug 93263
+    //font.setStyleStrategy(QFont::ForceIntegerMetrics);
 
     m_data->bold = font.bold();
     // WebKit allows font size zero but QFont does not. We will return
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp
index c992efc..1f77ec4 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp
@@ -27,6 +27,7 @@
 #include "FontDescription.h"
 #include "FontFallbackList.h"
 #include "FontSelector.h"
+#include "FontPlatformData.h"
 #if HAVE(QRAWFONT)
 #include "GlyphBuffer.h"
 #endif
@@ -471,6 +472,8 @@ void Font::drawEmphasisMarksForSimpleText(GraphicsContext* /* context */, const
 QFont Font::font() const
 {
     QFont f = primaryFont()->getQtFont();
+    f.setWeight(toQFontWeight(weight()));
+    f.setItalic(italic());
     if (m_letterSpacing != 0)
         f.setLetterSpacing(QFont::AbsoluteSpacing, m_letterSpacing);
     if (m_wordSpacing != 0)
diff --git src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp
index 0c8ce9e..5ba54d0 100644
--- src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp
@@ -41,6 +41,7 @@
 #include "PlatformString.h"
 #include "StillImageQt.h"
 #include "qwebsettings.h"
+#include "SharedBuffer.h"
 
 #include <QPixmap>
 #include <QPainter>
@@ -234,7 +235,8 @@ void BitmapImage::draw(GraphicsContext* ctxt, const FloatRect& dst,
         }
     }
 
-    ctxt->platformContext()->drawPixmap(normalizedDst, *image, normalizedSrc);
+    QByteArray a = QByteArray::fromRawData(data()->data(), data()->size());
+    ctxt->platformContext()->drawPixmap(normalizedDst, *image, normalizedSrc, &a);
 
     ctxt->setCompositeOperation(previousOperator);
 
diff --git src/3rdparty/webkit/Source/WebCore/platform/qt/KURLQt.cpp src/3rdparty/webkit/Source/WebCore/platform/qt/KURLQt.cpp
index f6d2a86..49df59a 100644
--- src/3rdparty/webkit/Source/WebCore/platform/qt/KURLQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/qt/KURLQt.cpp
@@ -46,7 +46,7 @@ String KURL::fileSystemPath() const
     if (!isValid() || !protocolIs("file"))
         return String();
 
-    return String(path());
+    return static_cast<QUrl>(*this).toLocalFile();
 }
 
 }
diff --git src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp
index 4db8bd1..0f405cb 100644
--- src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp
@@ -53,11 +53,17 @@ static int screenNumber(Widget* w)
 
 int screenDepth(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 32;
+
     return QApplication::desktop()->screen(screenNumber(w))->depth();
 }
 
 int screenDepthPerComponent(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 8;
+
     int depth = QApplication::desktop()->screen(0)->depth();
     if (w) {
         QWebPageClient* client = w->root()->hostWindow()->platformPageClient();
@@ -86,17 +92,26 @@ int screenDepthPerComponent(Widget* w)
 
 bool screenIsMonochrome(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return false;
+
     return QApplication::desktop()->screen(screenNumber(w))->colorCount() == 2;
 }
 
 FloatRect screenRect(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect(0,0,800,600);
+
     QRect r = QApplication::desktop()->screenGeometry(screenNumber(w));
     return FloatRect(r.x(), r.y(), r.width(), r.height());
 }
 
 FloatRect screenAvailableRect(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect(0,0,800,600);
+
     QRect r = QApplication::desktop()->availableGeometry(screenNumber(w));
     return FloatRect(r.x(), r.y(), r.width(), r.height());
 }
diff --git src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp
index f98df88..b1fe30d 100644
--- src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp
@@ -178,7 +178,13 @@ RenderThemeQt::RenderThemeQt(Page* page)
     : RenderTheme()
     , m_page(page)
     , m_lineEdit(0)
+    , m_fallbackStyle(0)
 {
+    if (QApplication::type() == QApplication::Tty) {
+        m_buttonFontFamily = "sans-serif";
+        return;
+    }
+
     QPushButton button;
     button.setAttribute(Qt::WA_MacSmallSize);
     QFont defaultButtonFont = QApplication::font(&button);
@@ -339,6 +345,9 @@ bool RenderThemeQt::supportsControlTints() const
 
 int RenderThemeQt::findFrameLineWidth(QStyle* style) const
 {
+    if (QApplication::type()==QApplication::Tty)
+        return 1;
+
 #ifndef QT_NO_LINEEDIT
     if (!m_lineEdit)
         m_lineEdit = new QLineEdit();
@@ -445,6 +454,9 @@ Color RenderThemeQt::systemColor(int cssValueId) const
 
 int RenderThemeQt::minimumMenuListSize(RenderStyle*) const
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 1;
+
     const QFontMetrics &fm = QApplication::fontMetrics();
     return fm.width(QLatin1Char('x'));
 }
diff --git src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp
index d648c53..f844d54 100644
--- src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp
@@ -54,6 +54,9 @@ static QWidget* qwidgetForPage(const Page* page)
 
 FloatRect screenRect(const Page* page)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect(0,0,800,600);
+
     QWidget* qw = qwidgetForPage(page);
     if (!qw)
         return FloatRect();
@@ -68,6 +71,9 @@ FloatRect screenRect(const Page* page)
 
 int screenDepth(const Page* page)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 32;
+
     QWidget* qw = qwidgetForPage(page);
     if (!qw)
         return 32;
@@ -77,6 +83,9 @@ int screenDepth(const Page* page)
 
 FloatRect usableScreenRect(const Page* page)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect();
+
     QWidget* qw = qwidgetForPage(page);
     if (!qw)
         return FloatRect();
diff --git src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp
index 5215e66..e033279 100644
--- src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp
+++ src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp
@@ -41,6 +41,7 @@
 #include "QWebPageClient.h"
 #include "ScrollView.h"
 
+#include <QApplication>
 #include <QCoreApplication>
 #include <QDebug>
 #include <QPaintEngine>
@@ -78,6 +79,9 @@ void Widget::setFocus(bool focused)
 void Widget::setCursor(const Cursor& cursor)
 {
 #ifndef QT_NO_CURSOR
+    if (QApplication::type() == QApplication::Tty)
+        return;
+
     ScrollView* view = root();
     if (!view)
         return;
diff --git src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h
index 236371a..ca52cbc 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h
+++ src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h
@@ -46,6 +46,7 @@ public:
         , m_includeLogicalLeftEdge(false)
         , m_includeLogicalRightEdge(false)
         , m_descendantsHaveSameLineHeightAndBaseline(true)
+        , m_isFirstAfterPageBreak(false)
 #ifndef NDEBUG
         , m_hasBadChildList(false)
 #endif
@@ -293,6 +294,7 @@ protected:
     bool m_hasTextChildren : 1;
     bool m_hasTextDescendants : 1;
     bool m_descendantsHaveSameLineHeightAndBaseline : 1;
+    bool m_isFirstAfterPageBreak : 1;
 
 #ifndef NDEBUG
     bool m_hasBadChildList;
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp
index 4ad1bfe..d8412db 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp
@@ -2048,7 +2048,7 @@ void RenderBlock::layoutBlockChild(RenderBox* child, MarginInfo& marginInfo, int
     setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);
 
     // Now we have a final top position.  See if it really does end up being different from our estimate.
-    if (logicalTopAfterClear != logicalTopEstimate) {
+    if (logicalTopAfterClear != logicalTopEstimate || (paginated && childRenderBlock && childRenderBlock->shouldBreakAtLineToAvoidWidow())) {
         if (child->shrinkToAvoidFloats()) {
             // The child's width depends on the line width.
             // When the child shifts to clear an item, its width can
@@ -2235,7 +2235,7 @@ void RenderBlock::markForPaginationRelayoutIfNeeded()
     if (needsLayout())
         return;
 
-    if (view()->layoutState()->pageLogicalHeightChanged() || (view()->layoutState()->pageLogicalHeight() && view()->layoutState()->pageLogicalOffset(logicalTop()) != pageLogicalOffset()))
+    if (view()->layoutState()->pageLogicalHeightChanged() || (view()->layoutState()->pageLogicalHeight() && view()->layoutState()->pageLogicalOffset(logicalTop()) != pageLogicalOffset()) || shouldBreakAtLineToAvoidWidow())
         setChildNeedsLayout(true, false);
 }
 
@@ -4156,6 +4156,10 @@ VisiblePosition RenderBlock::positionForPointWithInlineChildren(const IntPoint&
             continue;
         if (!firstRootBoxWithChildren)
             firstRootBoxWithChildren = root;
+
+        if (root->isFirstAfterPageBreak() && pointInLogicalContents.y() < root->logicalTop())
+            break;
+
         lastRootBoxWithChildren = root;
 
         // check if this root line box is located at this y coordinate
@@ -5717,6 +5721,23 @@ void RenderBlock::setPageLogicalOffset(int logicalOffset)
     m_rareData->m_pageLogicalOffset = logicalOffset;
 }
 
+void RenderBlock::setBreakAtLineToAvoidWidow(RootInlineBox* lineToBreak)
+{
+    ASSERT(lineToBreak);
+    if (!m_rareData)
+        m_rareData = adoptPtr(new RenderBlockRareData(this));
+    m_rareData->m_shouldBreakAtLineToAvoidWidow = true;
+    m_rareData->m_lineBreakToAvoidWidow = lineToBreak;
+}
+
+void RenderBlock::clearShouldBreakAtLineToAvoidWidow() const
+{
+    if (!m_rareData)
+        return;
+    m_rareData->m_shouldBreakAtLineToAvoidWidow = false;
+    m_rareData->m_lineBreakToAvoidWidow = 0;
+}
+
 void RenderBlock::absoluteRects(Vector<IntRect>& rects, int tx, int ty)
 {
     // For blocks inside inlines, we go ahead and include margins so that we run right up to the
@@ -6045,7 +6066,8 @@ int RenderBlock::applyAfterBreak(RenderBox* child, int logicalOffset, MarginInfo
 
 int RenderBlock::adjustForUnsplittableChild(RenderBox* child, int logicalOffset, bool includeMargins)
 {
-    bool isUnsplittable = child->isReplaced() || child->scrollsOverflow();
+    bool isUnsplittable = child->isReplaced() || child->scrollsOverflow() ||
+                          child->style()->pageBreakInside() == PBAVOID;
     if (!isUnsplittable)
         return logicalOffset;
     int childLogicalHeight = logicalHeightForChild(child) + (includeMargins ? marginBeforeForChild(child) + marginAfterForChild(child) : 0);
@@ -6090,20 +6112,26 @@ void RenderBlock::adjustLinePositionForPagination(RootInlineBox* lineBox, int& d
         layoutState->m_columnInfo->updateMinimumColumnHeight(lineHeight);
     logicalOffset += delta;
     lineBox->setPaginationStrut(0);
+    lineBox->setIsFirstAfterPageBreak(false);
     if (!pageLogicalHeight || lineHeight > pageLogicalHeight)
         return;
     IntSize offsetDelta = layoutState->m_layoutOffset - layoutState->m_pageOffset;
     int offset = isHorizontalWritingMode() ? offsetDelta.height() : offsetDelta.width();
     int remainingLogicalHeight = pageLogicalHeight - (offset + logicalOffset) % pageLogicalHeight;
-    if (remainingLogicalHeight < lineHeight) {
+    if (remainingLogicalHeight < lineHeight || (shouldBreakAtLineToAvoidWidow() && lineBreakToAvoidWidow() == lineBox)) {
+        if (shouldBreakAtLineToAvoidWidow() && lineBreakToAvoidWidow() == lineBox)
+            clearShouldBreakAtLineToAvoidWidow();
         int totalLogicalHeight = lineHeight + max(0, logicalOffset);
-        if (lineBox == firstRootBox() && totalLogicalHeight < pageLogicalHeight && !isPositioned() && !isTableCell())
+        if (((lineBox == firstRootBox() && totalLogicalHeight < pageLogicalHeight) || (!style()->hasAutoOrphans() && style()->orphans() >= lineCount()))
+            && !isPositioned() && !isTableCell())
             setPaginationStrut(remainingLogicalHeight + max(0, logicalOffset));
         else {
             delta += remainingLogicalHeight;
             lineBox->setPaginationStrut(remainingLogicalHeight);
+            lineBox->setIsFirstAfterPageBreak(true);
         }
-    }  
+    } else if (remainingLogicalHeight == pageLogicalHeight && lineBox != firstRootBox())
+        lineBox->setIsFirstAfterPageBreak(true);
 }
 
 int RenderBlock::collapsedMarginBeforeForChild(RenderBox* child) const
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h
index 6e420ca..28c3332 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h
@@ -169,7 +169,12 @@ public:
 
     int paginationStrut() const { return m_rareData ? m_rareData->m_paginationStrut : 0; }
     void setPaginationStrut(int);
-    
+
+    bool shouldBreakAtLineToAvoidWidow() const { return m_rareData && m_rareData->m_shouldBreakAtLineToAvoidWidow; }
+    void clearShouldBreakAtLineToAvoidWidow() const;
+    RootInlineBox* lineBreakToAvoidWidow() const { return m_rareData ? m_rareData->m_lineBreakToAvoidWidow : 0; }
+    void setBreakAtLineToAvoidWidow(RootInlineBox*);
+
     // The page logical offset is the object's offset from the top of the page in the page progression
     // direction (so an x-offset in vertical text and a y-offset for horizontal text).
     int pageLogicalOffset() const { return m_rareData ? m_rareData->m_pageLogicalOffset : 0; }
@@ -785,6 +790,8 @@ private:
             : m_margins(positiveMarginBeforeDefault(block), negativeMarginBeforeDefault(block), positiveMarginAfterDefault(block), negativeMarginAfterDefault(block))
             , m_paginationStrut(0)
             , m_pageLogicalOffset(0)
+            , m_shouldBreakAtLineToAvoidWidow(false)
+            , m_lineBreakToAvoidWidow(0)
         { 
         }
 
@@ -809,6 +816,9 @@ private:
         MarginValues m_margins;
         int m_paginationStrut;
         int m_pageLogicalOffset;
+
+        bool m_shouldBreakAtLineToAvoidWidow;
+        RootInlineBox* m_lineBreakToAvoidWidow;
      };
 
     OwnPtr<RenderBlockRareData> m_rareData;
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp
index 2e92801..974773c 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp
@@ -34,6 +34,7 @@
 #include "RenderListMarker.h"
 #include "RenderRubyRun.h"
 #include "RenderView.h"
+#include "RenderTableRow.h"
 #include "Settings.h"
 #include "TextBreakIterator.h"
 #include "TextRun.h"
@@ -816,6 +817,15 @@ RootInlineBox* RenderBlock::createLineBoxesFromBidiRuns(BidiRunList<BidiRun>& bi
     return lineBox;
 }
 
+static inline bool isTableCellWithPageBreakInsideAvoid(RenderBlock *block)
+{
+    if (!block->isTableCell())
+        return false;
+
+    RenderTableRow *row = toRenderTableRow(block->parent());
+    return row && row->style()->pageBreakInside() == PBAVOID;
+}
+
 void RenderBlock::layoutRunsAndFloats(bool fullLayout, bool hasInlineChild, Vector<FloatWithRect>& floats, int& repaintLogicalTop, int& repaintLogicalBottom)
 {
     // We want to skip ahead to the first dirty line
@@ -956,7 +966,8 @@ void RenderBlock::layoutRunsAndFloats(bool fullLayout, bool hasInlineChild, Vect
                     repaintLogicalBottom = max(repaintLogicalBottom, lineBox->logicalBottomVisualOverflow());
                 }
 
-                if (paginated) {
+                // table cell pagination in case of page-break-inside: avoid is handled in RenderTableSection
+                if (paginated && !isTableCellWithPageBreakInsideAvoid(this)) {
                     int adjustment = 0;
                     adjustLinePositionForPagination(lineBox, adjustment);
                     if (adjustment) {
@@ -1013,6 +1024,63 @@ void RenderBlock::layoutRunsAndFloats(bool fullLayout, bool hasInlineChild, Vect
         resolver.setPosition(end);
     }
 
+    if (paginated && !style()->hasAutoWidows()) {
+        // Check the line boxes to make sure we didn't create unacceptable widows.
+        // However, we'll prioritize orphans - so nothing we do here should create
+        // a new orphan.
+
+        RootInlineBox* lineBox = lastRootBox();
+
+        // Count from the end of the block backwards, to see how many hanging
+        // lines we have.
+        RootInlineBox* firstLineInBlock = firstRootBox();
+        int numLinesHanging = 1;
+        while (lineBox && lineBox != firstLineInBlock && !lineBox->isFirstAfterPageBreak()) {
+            ++numLinesHanging;
+            lineBox = lineBox->prevRootBox();
+        }
+
+        // If there were no breaks in the block, we didn't create any widows.
+        if (!lineBox || !lineBox->isFirstAfterPageBreak() || lineBox == firstLineInBlock)
+            return;
+
+        if (numLinesHanging < style()->widows()) {
+            // We have detected a widow. Now we need to work out how many
+            // lines there are on the previous page, and how many we need
+            // to steal.
+            int numLinesNeeded = style()->widows() - numLinesHanging;
+            RootInlineBox* currentFirstLineOfNewPage = lineBox;
+
+            // Count the number of lines in the previous page.
+            lineBox = lineBox->prevRootBox();
+            int numLinesInPreviousPage = 1;
+            while (lineBox && lineBox != firstLineInBlock && !lineBox->isFirstAfterPageBreak()) {
+                ++numLinesInPreviousPage;
+                lineBox = lineBox->prevRootBox();
+            }
+
+            // If there was an explicit value for orphans, respect that. If not, we still
+            // shouldn't create a situation where we make an orphan bigger than the initial value.
+            // This means that setting widows implies we also care about orphans, but given
+            // the specification says the initial orphan value is non-zero, this is ok. The
+            // author is always free to set orphans explicitly as well.
+            int orphans = style()->hasAutoOrphans() ? style()->initialOrphans() : style()->orphans();
+            int numLinesAvailable = numLinesInPreviousPage - orphans;
+            if (numLinesAvailable <= 0)
+                return;
+
+            int numLinesToTake = min(numLinesAvailable, numLinesNeeded);
+            // Wind back from our first widowed line.
+            lineBox = currentFirstLineOfNewPage;
+            for (int i = 0; i < numLinesToTake; ++i)
+                lineBox = lineBox->prevRootBox();
+
+            // We now want to break at this line. Remember for next layout and trigger relayout.
+            setBreakAtLineToAvoidWidow(lineBox);
+            markLinesDirtyInBlockRange(lastRootBox()->lineBottom(), lineBox->lineBottom(), lineBox);
+        }
+    }
+
     if (endLine) {
         if (endLineMatched) {
             // Attach all the remaining lines, and then adjust their y-positions as needed.
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderInline.cpp src/3rdparty/webkit/Source/WebCore/rendering/RenderInline.cpp
index 5bd726d..49f0224 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderInline.cpp
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderInline.cpp
@@ -99,7 +99,8 @@ void RenderInline::destroy()
                 for (InlineFlowBox* box = firstLineBox(); box; box = box->nextLineBox())
                     box->remove();
             }
-        }
+        } else if (parent())
+            parent()->dirtyLinesFromChangedChild(this);
     }
 
     m_lineBoxes.deleteLineBoxes(renderArena());
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp
index 73b0801..9f91067 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp
@@ -37,6 +37,7 @@
 #include "RenderLayer.h"
 #include "RenderTableCell.h"
 #include "RenderTableCol.h"
+#include "RenderTableRow.h"
 #include "RenderTableSection.h"
 #include "RenderView.h"
 
@@ -302,11 +303,20 @@ void RenderTable::layout()
 
     bool collapsing = collapseBorders();
 
+    // repeat header and footer on each page
+    int headHeight = 0;
+    int footHeight = 0;
     for (RenderObject* child = firstChild(); child; child = child->nextSibling()) {
         if (child->isTableSection()) {
             child->layoutIfNeeded();
             RenderTableSection* section = toRenderTableSection(child);
-            totalSectionLogicalHeight += section->calcRowLogicalHeight();
+            int rowHeight = section->calcRowLogicalHeight();
+            if (child == m_head) {
+                headHeight = rowHeight;
+            } else if (child == m_foot) {
+                footHeight = rowHeight;
+            }
+            totalSectionLogicalHeight += rowHeight;
             if (collapsing)
                 section->recalcOuterBorder();
             ASSERT(!section->needsLayout());
@@ -320,6 +330,34 @@ void RenderTable::layout()
     if (m_caption)
         m_caption->layoutIfNeeded();
 
+    // Bump table to next page if we can't fit the caption, thead and first body cell if first row has page-break-inside: avoid
+    setPaginationStrut(0);
+    if (view()->layoutState()->pageLogicalHeight()) {
+        LayoutState* layoutState = view()->layoutState();
+        const int pageLogicalHeight = layoutState->m_pageLogicalHeight;
+        const int remainingLogicalHeight = pageLogicalHeight - layoutState->pageLogicalOffset(0) % pageLogicalHeight;
+        if (remainingLogicalHeight > 0) {
+            int requiredHeight = headHeight;
+            if (m_caption && m_caption->style()->captionSide() != CAPBOTTOM) {
+                requiredHeight += m_caption->logicalHeight() + m_caption->marginBefore() + m_caption->marginAfter();
+            }
+            if (m_firstBody) {
+                // FIXME: Calculate maximum required height across all cells in first body row
+                if (m_firstBody->numRows() > 0 && m_firstBody->numColumns() > 0) {
+                    RenderTableCell* firstCell = m_firstBody->primaryCellAt(0, 0);
+                    if (firstCell) {
+                        RenderTableRow *firstRow = toRenderTableRow(firstCell->parent());
+                        if (firstRow && firstRow->style()->pageBreakInside() == PBAVOID)
+                            requiredHeight += firstCell->contentLogicalHeight() + firstCell->paddingTop(false) + firstCell->paddingBottom(false) + vBorderSpacing();
+                    }
+                }
+            }
+            if (requiredHeight > remainingLogicalHeight && requiredHeight < pageLogicalHeight) {
+                setPaginationStrut(remainingLogicalHeight);
+            }
+        }
+    }
+
     // If any table section moved vertically, we will just repaint everything from that
     // section down (it is quite unlikely that any of the following sections
     // did not shift).
@@ -352,12 +390,6 @@ void RenderTable::layout()
         computedLogicalHeight = computePercentageLogicalHeight(logicalHeightLength);
     computedLogicalHeight = max(0, computedLogicalHeight);
 
-    for (RenderObject* child = firstChild(); child; child = child->nextSibling()) {
-        if (child->isTableSection())
-            // FIXME: Distribute extra height between all table body sections instead of giving it all to the first one.
-            toRenderTableSection(child)->layoutRows(child == m_firstBody ? max(0, computedLogicalHeight - totalSectionLogicalHeight) : 0);
-    }
-
     if (!m_firstBody && computedLogicalHeight > totalSectionLogicalHeight && !document()->inQuirksMode()) {
         // Completely empty tables (with no sections or anything) should at least honor specified height
         // in strict mode.
@@ -377,6 +409,9 @@ void RenderTable::layout()
         }
         section->setLogicalLocation(sectionLogicalLeft, logicalHeight());
 
+        // FIXME: Distribute extra height between all table body sections instead of giving it all to the first one.
+        section->layoutRows(section == m_firstBody ? max(0, computedLogicalHeight - totalSectionLogicalHeight) : 0, section == m_head ? 0 : headHeight, section == m_foot ? 0 : footHeight);
+
         setLogicalHeight(logicalHeight() + section->logicalHeight());
         section = sectionBelow(section);
     }
@@ -503,7 +538,59 @@ void RenderTable::paintObject(PaintInfo& paintInfo, int tx, int ty)
             child->paint(info, childPoint.x(), childPoint.y());
         }
     }
-    
+
+    bool repaintedHead = false;
+    IntPoint repaintedHeadPoint;
+    bool repaintedFoot = false;
+    IntPoint repaintedFootPoint;
+    if (view()->pageLogicalHeight()) {
+        // re-paint header/footer if table is split over multiple pages
+        if (m_head) {
+            IntPoint childPoint = flipForWritingMode(m_head, IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+            if (info.rect.y() > childPoint.y() + m_head->y()) {
+                repaintedHeadPoint = IntPoint(childPoint.x(), info.rect.y() - m_head->y());
+                repaintedHead = true;
+                dynamic_cast<RenderObject*>(m_head)->paint(info, repaintedHeadPoint.x(), repaintedHeadPoint.y());
+            }
+        }
+        if (m_foot) {
+            IntPoint childPoint = flipForWritingMode(m_foot, IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+            if (info.rect.y() + info.rect.height() < childPoint.y() + m_foot->y()) {
+                // find actual end of table on current page
+                int dy = 0;
+                const int max_dy = info.rect.y() + info.rect.height();
+                const int vspace = vBorderSpacing();
+                for (RenderObject* section = firstChild(); section; section = section->nextSibling()) {
+                    if (section->isTableSection()) {
+                        if (toRenderBox(section)->y() > max_dy) {
+                            continue;
+                        }
+                        int i = 0;
+                        for(RenderObject* row = section->firstChild(); row; row = row->nextSibling()) {
+                            if (!row->isTableRow()) {
+                                continue;
+                            }
+                            // get actual bottom-y position of this row - pretty complicated, how could this be simplified?
+                            // note how we have to take the rowPoint and section's y-offset into account, see e.g.
+                            // RenderTableSection::paint where this is also done...
+                            IntPoint rowPoint = flipForWritingMode(toRenderBox(row), IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+                            int row_dy = rowPoint.y() + toRenderBox(row)->y() + toRenderBox(row)->logicalHeight() + toRenderBox(section)->y();
+                            if (row_dy < max_dy && row_dy > dy) {
+                                dy = row_dy;
+                            } else if (row_dy > max_dy) {
+                                break;
+                            }
+                            i++;
+                        }
+                    }
+                }
+                repaintedFoot = true;
+                repaintedFootPoint = IntPoint(childPoint.x(), dy - m_foot->y());
+                dynamic_cast<RenderObject*>(m_foot)->paint(info, repaintedFootPoint.x(), repaintedFootPoint.y());
+            }
+        }
+    }
+
     if (collapseBorders() && paintPhase == PaintPhaseChildBlockBackground && style()->visibility() == VISIBLE) {
         // Collect all the unique border styles that we want to paint in a sorted list.  Once we
         // have all the styles sorted, we then do individual passes, painting each style of border
@@ -522,6 +609,12 @@ void RenderTable::paintObject(PaintInfo& paintInfo, int tx, int ty)
             for (RenderObject* child = firstChild(); child; child = child->nextSibling())
                 if (child->isTableSection()) {
                     IntPoint childPoint = flipForWritingMode(toRenderTableSection(child), IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+                    // also repaint borders of header/footer if required
+                    if (child == m_head && repaintedHead) {
+                        childPoint = repaintedHeadPoint;
+                    } else if (child == m_foot && repaintedFoot) {
+                        childPoint = repaintedFootPoint;
+                    }
                     child->paint(info, childPoint.x(), childPoint.y());
                 }
         }
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp
index 7d414a0..3482f1d 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp
@@ -414,7 +414,7 @@ void RenderTableSection::layout()
     setNeedsLayout(false);
 }
 
-int RenderTableSection::layoutRows(int toAdd)
+int RenderTableSection::layoutRows(int toAdd, int headHeight, int footHeight)
 {
 #ifndef NDEBUG
     setNeedsLayoutIsForbidden(true);
@@ -496,12 +496,52 @@ int RenderTableSection::layoutRows(int toAdd)
 
     LayoutStateMaintainer statePusher(view(), this, IntSize(x(), y()), style()->isFlippedBlocksWritingMode());
 
+    // Calculate logical row heights
+    Vector<int> logicalRowHeights;
+    logicalRowHeights.resize(totalRows);
+    for (int r = 0; r < totalRows; r++) {
+        logicalRowHeights[r] = m_rowPos[r + 1] - m_rowPos[r] - vspacing;
+    }
+
+    // Make sure that cell contents do not overlap a page break
+    if (view()->layoutState()->pageLogicalHeight()) {
+        LayoutState* layoutState = view()->layoutState();
+        int pageLogicalHeight = layoutState->m_pageLogicalHeight;
+        int pageOffset = 0;
+
+        for (int r = 0; r < totalRows; ++r) {
+            m_rowPos[r] += pageOffset;
+            int remainingLogicalHeight = pageLogicalHeight - layoutState->pageLogicalOffset(m_rowPos[r]) % pageLogicalHeight;
+            int availableHeight = remainingLogicalHeight - footHeight - vspacing;
+            RenderTableRow* rowRenderer = m_grid[r].rowRenderer;
+
+            for (int c = 0; c < nEffCols; c++) {
+                CellStruct& cs = cellAt(r, c);
+                RenderTableCell* cell = cs.primaryCell();
+
+                if (!cell || cs.inColSpan || cell->row() != r || !rowRenderer || rowRenderer->style()->pageBreakInside() != PBAVOID)
+                    continue;
+
+                int cellRequiredHeight = cell->contentLogicalHeight() + cell->paddingTop(false) + cell->paddingBottom(false);
+                int requiredHeight = max(logicalRowHeights[r], cellRequiredHeight);
+                if (requiredHeight >= availableHeight && requiredHeight < pageLogicalHeight) {
+                    pageOffset += remainingLogicalHeight + headHeight;
+                    if (requiredHeight > availableHeight) {
+                        m_rowPos[r] += remainingLogicalHeight + headHeight;
+                    }
+                    break;
+                }
+            }
+        }
+        m_rowPos[totalRows] += pageOffset;
+    }
+
     for (int r = 0; r < totalRows; r++) {
         // Set the row's x/y position and width/height.
         if (RenderTableRow* rowRenderer = m_grid[r].rowRenderer) {
             rowRenderer->setLocation(0, m_rowPos[r]);
             rowRenderer->setLogicalWidth(logicalWidth());
-            rowRenderer->setLogicalHeight(m_rowPos[r + 1] - m_rowPos[r] - vspacing);
+            rowRenderer->setLogicalHeight(logicalRowHeights[r]);
             rowRenderer->updateLayerTransform();
         }
 
@@ -513,7 +553,11 @@ int RenderTableSection::layoutRows(int toAdd)
                 continue;
 
             rindx = cell->row();
-            rHeight = m_rowPos[rindx + cell->rowSpan()] - m_rowPos[rindx] - vspacing;
+            if (cell->rowSpan() == 1) {
+                rHeight = logicalRowHeights[rindx];
+            } else {
+                rHeight = m_rowPos[rindx + cell->rowSpan()] - m_rowPos[rindx] - vspacing;
+            }
             
             // Force percent height children to lay themselves out again.
             // This will cause these children to grow to fill the cell.
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h
index db6edc2..9d912a0 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h
+++ src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h
@@ -49,7 +49,7 @@ public:
 
     void setCellLogicalWidths();
     int calcRowLogicalHeight();
-    int layoutRows(int logicalHeight);
+    int layoutRows(int logicalHeight, int headHeight, int footHeight);
 
     RenderTable* table() const { return toRenderTable(parent()); }
 
diff --git src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h
index 575a10d..cf94af6 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h
+++ src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h
@@ -53,6 +53,9 @@ public:
     int paginationStrut() const { return m_paginationStrut; }
     void setPaginationStrut(int s) { m_paginationStrut = s; }
 
+    bool isFirstAfterPageBreak() const { return m_isFirstAfterPageBreak; }
+    void setIsFirstAfterPageBreak(bool isFirstAfterPageBreak) { m_isFirstAfterPageBreak = isFirstAfterPageBreak; }
+
     int selectionTop() const;
     int selectionBottom() const;
     int selectionHeight() const { return max(0, selectionBottom() - selectionTop()); }
diff --git src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h
index 938b297..8d52acc 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h
+++ src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h
@@ -637,6 +637,8 @@ public:
 
     short widows() const { return rareInheritedData->widows; }
     short orphans() const { return rareInheritedData->orphans; }
+    bool hasAutoWidows() const { return rareInheritedData->m_hasAutoWidows; }
+    bool hasAutoOrphans() const { return rareInheritedData->m_hasAutoOrphans; }
     EPageBreak pageBreakInside() const { return static_cast<EPageBreak>(noninherited_flags._page_break_inside); }
     EPageBreak pageBreakBefore() const { return static_cast<EPageBreak>(noninherited_flags._page_break_before); }
     EPageBreak pageBreakAfter() const { return static_cast<EPageBreak>(noninherited_flags._page_break_after); }
@@ -1011,8 +1013,10 @@ public:
     int zIndex() const { return m_box->zIndex(); }
     void setZIndex(int v) { SET_VAR(m_box, m_hasAutoZIndex, false); SET_VAR(m_box, m_zIndex, v) }
 
-    void setWidows(short w) { SET_VAR(rareInheritedData, widows, w); }
-    void setOrphans(short o) { SET_VAR(rareInheritedData, orphans, o); }
+    void setHasAutoWidows() { SET_VAR(rareInheritedData, m_hasAutoWidows, true); SET_VAR(rareInheritedData, widows, initialWidows()) }
+    void setWidows(short w) { SET_VAR(rareInheritedData, m_hasAutoWidows, false); SET_VAR(rareInheritedData, widows, w); }
+    void setHasAutoOrphans() { SET_VAR(rareInheritedData, m_hasAutoOrphans, true); SET_VAR(rareInheritedData, orphans, initialOrphans()) }
+    void setOrphans(short o) { SET_VAR(rareInheritedData, m_hasAutoOrphans, false); SET_VAR(rareInheritedData, orphans, o); }
     void setPageBreakInside(EPageBreak b) { noninherited_flags._page_break_inside = b; }
     void setPageBreakBefore(EPageBreak b) { noninherited_flags._page_break_before = b; }
     void setPageBreakAfter(EPageBreak b) { noninherited_flags._page_break_after = b; }
diff --git src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp
index c384611..a7ece4f 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp
+++ src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp
@@ -36,6 +36,8 @@ StyleRareInheritedData::StyleRareInheritedData()
     , m_effectiveZoom(RenderStyle::initialZoom())
     , widows(RenderStyle::initialWidows())
     , orphans(RenderStyle::initialOrphans())
+    , m_hasAutoWidows(true)
+    , m_hasAutoOrphans(true)
     , textSecurity(RenderStyle::initialTextSecurity())
     , userModify(READ_ONLY)
     , wordBreak(RenderStyle::initialWordBreak())
@@ -70,6 +72,8 @@ StyleRareInheritedData::StyleRareInheritedData(const StyleRareInheritedData& o)
     , m_effectiveZoom(o.m_effectiveZoom)
     , widows(o.widows)
     , orphans(o.orphans)
+    , m_hasAutoWidows(o.m_hasAutoWidows)
+    , m_hasAutoOrphans(o.m_hasAutoOrphans)
     , textSecurity(o.textSecurity)
     , userModify(o.userModify)
     , wordBreak(o.wordBreak)
@@ -120,6 +124,8 @@ bool StyleRareInheritedData::operator==(const StyleRareInheritedData& o) const
         && m_effectiveZoom == o.m_effectiveZoom
         && widows == o.widows
         && orphans == o.orphans
+        && m_hasAutoWidows == o.m_hasAutoWidows
+        && m_hasAutoOrphans == o.m_hasAutoOrphans
         && textSecurity == o.textSecurity
         && userModify == o.userModify
         && wordBreak == o.wordBreak
diff --git src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h
index da410f1..b853cba 100644
--- src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h
+++ src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h
@@ -68,6 +68,8 @@ public:
     // Paged media properties.
     short widows;
     short orphans;
+    unsigned m_hasAutoWidows : 1;
+    unsigned m_hasAutoOrphans : 1;
     
     unsigned textSecurity : 2; // ETextSecurity
     unsigned userModify : 2; // EUserModify (editing)
diff --git src/3rdparty/webkit/Source/WebKit.pro src/3rdparty/webkit/Source/WebKit.pro
index 9be0f4a..1731066 100644
--- src/3rdparty/webkit/Source/WebKit.pro
+++ src/3rdparty/webkit/Source/WebKit.pro
@@ -1,16 +1,11 @@
 TEMPLATE = subdirs
 CONFIG += ordered
+DEFINES += Q_NODLL Q_DECL_IMPORT QT_STATIC_BUILD STATIC
 
 include(WebKit.pri)
 
-!v8 {
-    exists($$PWD/JavaScriptCore/JavaScriptCore.pro): SUBDIRS += JavaScriptCore/JavaScriptCore.pro
-    exists($$PWD/JavaScriptCore/jsc.pro): SUBDIRS += JavaScriptCore/jsc.pro
-}
-
 webkit2:exists($$PWD/WebKit2/WebKit2.pro): SUBDIRS += WebKit2/WebKit2.pro
 
-SUBDIRS += WebCore
 SUBDIRS += WebKit/qt/QtWebKit.pro
 
 webkit2 {
@@ -22,8 +17,6 @@ contains(QT_CONFIG, declarative) {
     exists($$PWD/WebKit/qt/declarative): SUBDIRS += WebKit/qt/declarative
 }
 
-exists($$PWD/WebKit/qt/tests): SUBDIRS += WebKit/qt/tests
-
 build-qtscript {
     SUBDIRS += \
         JavaScriptCore/qt/api/QtScript.pro \
@@ -38,5 +31,3 @@ symbian {
     install.commands = $(MAKE) -C WebCore install
     QMAKE_EXTRA_TARGETS += install
 }
-
-include(WebKit/qt/docs/docs.pri)
diff --git src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h
index 4b1a758..2ad7f1f 100644
--- src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h
+++ src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h
@@ -170,6 +170,7 @@ private:
     friend class QWebHitTestResult;
     friend class QWebHitTestResultPrivate;
     friend class QWebPage;
+    friend class QWebPrinter;
 
 #if defined(WTF_USE_V8) && WTF_USE_V8
     friend class V8::Bindings::QtWebElementRuntime;
diff --git src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp
index 5ea7059..ee80c94 100644
--- src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp
+++ src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp
@@ -216,6 +216,116 @@ static inline ResourceRequestCachePolicy cacheLoadControlToCachePolicy(uint cach
     return WebCore::UseProtocolCachePolicy;
 }
 
+#ifndef QT_NO_PRINTER
+QWebPrinterPrivate::QWebPrinterPrivate(const QWebFrame *f, QPaintDevice *printer, QPainter &p)
+    : printContext(f->d->frame)
+    , painter(p)
+    , frame(f)
+    , graphicsContext(&p)
+{
+    const qreal zoomFactorX = (qreal)printer->logicalDpiX() / qt_defaultDpi();
+    const qreal zoomFactorY = (qreal)printer->logicalDpiY() / qt_defaultDpi();
+    IntRect pageRect(0, 0,
+                     int(printer->width() / zoomFactorX),
+                     int(printer->height() / zoomFactorY));
+    
+    printContext.begin(pageRect.width(), pageRect.height());
+    float pageHeight = 0;
+    printContext.computePageRects(pageRect, /* headerHeight */ 0, /* footerHeight */ 0, /* userScaleFactor */ 1.0, pageHeight);
+    
+    painter.scale(zoomFactorX, zoomFactorY);
+    printWidth = pageRect.width();
+}
+
+QWebPrinterPrivate::~QWebPrinterPrivate() 
+{
+    printContext.end();
+}
+
+/*!
+    \class QWebPrinter
+    \since 4.7
+    \brief The QWebPrinter controls printing of a \l{QWebFrame::}
+
+    \inmodule QtWebKit
+
+    \sa QWebFrame
+*/
+QWebPrinter::QWebPrinter(const QWebFrame *frame, QPaintDevice *printer, QPainter &painter)
+    : d(new QWebPrinterPrivate(frame, printer, painter))
+{}
+
+QWebPrinter::~QWebPrinter() 
+{
+    delete d; 
+}
+
+/*!
+    Print a page of the frame. \a i is  the number of the page to print, 
+    and must be between 1 and \fn QWebPrinter::pageCount() .
+*/
+void QWebPrinter::spoolPage(int i) const
+{
+    if (i < 1 || i > d->printContext.pageCount()) 
+        return;
+    d->printContext.spoolPage(d->graphicsContext, i - 1, d->printWidth);
+}
+
+/*!
+    Returns the number of pages of the frame when printed.
+*/
+int QWebPrinter::pageCount() const
+{
+    return d->printContext.pageCount();
+}
+
+QPair<int, QRectF> QWebPrinter::elementLocation(const QWebElement & e)
+{
+    //Compute a mapping from node to render object once and for all
+    if (d->elementToRenderObject.empty())
+    for (WebCore::RenderObject * o=d->frame->d->frame->document()->renderer(); o; o=o->nextInPreOrder())
+        if (o->node())
+            d->elementToRenderObject[o->node()] = o;
+        
+    if (!d->elementToRenderObject.contains(e.m_element))
+        return QPair<int,QRectF>(-1, QRectF());
+    const WebCore::RenderObject * ro = d->elementToRenderObject[e.m_element];
+    const Vector<IntRect> & pageRects = d->printContext.getPageRects();
+
+    if (pageRects.size() == 0)
+        return QPair<int,QRectF>(-1, QRectF());
+
+    WebCore::RenderView *root = toRenderView(d->frame->d->frame->document()->renderer());
+    //We need the scale factor, because pages are shrinked
+    float scale = (float)d->printWidth / (float)root->width();
+
+    QRectF r(const_cast<WebCore::RenderObject *>(ro)->absoluteBoundingBoxRect());
+    
+    int low=0;
+    int high=pageRects.size();
+    int c = r.y() + r.height() / 2;
+    while(low <= high) {
+        int m = (low+high)/2;
+        if(c < pageRects[m].y())
+            high = m-1;
+        else if(c > pageRects[m].maxY())
+            low = m +1;
+        else {
+            QRectF tr = r.translated(0, -pageRects[m].y());
+            return QPair<int, QRectF>(m+1, QRect(tr.x() * scale, tr.y()*scale, tr.width()*scale, tr.height()*scale));
+        }
+    }
+    return QPair<int,QRectF>(-1, QRectF());
+}
+
+/*!
+    Return the painter used for printing.
+*/
+QPainter * QWebPrinter::painter() {
+    return &d->painter;
+}
+#endif //QT_NO_PRINTER
+
 QWebFrameData::QWebFrameData(WebCore::Page* parentPage, WebCore::Frame* parentFrame,
                              WebCore::HTMLFrameOwnerElement* ownerFrameElement,
                              const WTF::String& frameName)
@@ -1434,25 +1544,8 @@ bool QWebFrame::event(QEvent *e)
 void QWebFrame::print(QPrinter *printer) const
 {
     QPainter painter;
-    if (!painter.begin(printer))
-        return;
-
-    const qreal zoomFactorX = (qreal)printer->logicalDpiX() / qt_defaultDpi();
-    const qreal zoomFactorY = (qreal)printer->logicalDpiY() / qt_defaultDpi();
-
-    PrintContext printContext(d->frame);
-    float pageHeight = 0;
-
-    QRect qprinterRect = printer->pageRect();
-
-    IntRect pageRect(0, 0,
-                     int(qprinterRect.width() / zoomFactorX),
-                     int(qprinterRect.height() / zoomFactorY));
-
-    printContext.begin(pageRect.width());
-
-    printContext.computePageRects(pageRect, /* headerHeight */ 0, /* footerHeight */ 0, /* userScaleFactor */ 1.0, pageHeight);
-
+    painter.begin(printer);
+    QWebPrinter p(this, printer, painter);
     int docCopies;
     int pageCopies;
     if (printer->collateCopies()) {
@@ -1469,11 +1562,12 @@ void QWebFrame::print(QPrinter *printer) const
 
     if (fromPage == 0 && toPage == 0) {
         fromPage = 1;
-        toPage = printContext.pageCount();
+        toPage = p.pageCount();
     }
     // paranoia check
     fromPage = qMax(1, fromPage);
-    toPage = qMin(static_cast<int>(printContext.pageCount()), toPage);
+    toPage = qMin(static_cast<int>(p.pageCount()), toPage);
+
     if (toPage < fromPage) {
         // if the user entered a page range outside the actual number
         // of printable pages, just return
@@ -1486,20 +1580,15 @@ void QWebFrame::print(QPrinter *printer) const
         toPage = tmp;
         ascending = false;
     }
-
-    painter.scale(zoomFactorX, zoomFactorY);
-    GraphicsContext ctx(&painter);
-
     for (int i = 0; i < docCopies; ++i) {
         int page = fromPage;
         while (true) {
             for (int j = 0; j < pageCopies; ++j) {
                 if (printer->printerState() == QPrinter::Aborted
                     || printer->printerState() == QPrinter::Error) {
-                    printContext.end();
                     return;
                 }
-                printContext.spoolPage(ctx, page - 1, pageRect.width());
+                p.spoolPage(page);
                 if (j < pageCopies - 1)
                     printer->newPage();
             }
@@ -1518,8 +1607,7 @@ void QWebFrame::print(QPrinter *printer) const
         if ( i < docCopies - 1)
             printer->newPage();
     }
-
-    printContext.end();
+    painter.end();
 }
 #endif // QT_NO_PRINTER
 
diff --git src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h
index 3c5a28e..99771f8 100644
--- src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h
+++ src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h
@@ -21,6 +21,8 @@
 #ifndef QWEBFRAME_H
 #define QWEBFRAME_H
 
+#define  __EXTENSIVE_WKHTMLTOPDF_QT_HACK__
+
 #include <QtCore/qobject.h>
 #include <QtCore/qurl.h>
 #include <QtCore/qvariant.h>
@@ -42,6 +44,9 @@ class QPrinter;
 QT_END_NAMESPACE
 
 class QWebNetworkRequest;
+#ifndef QT_NO_PRINTER
+class QWebPrinterPrivate;
+#endif
 class QWebFramePrivate;
 class QWebPage;
 class QWebHitTestResult;
@@ -103,6 +108,20 @@ private:
     friend class QWebPage;
 };
 
+#ifndef QT_NO_PRINTER
+class QWEBKIT_EXPORT QWebPrinter {
+public:
+    QWebPrinter(const QWebFrame * frame, QPaintDevice * printer, QPainter &painter);
+    ~QWebPrinter();
+    void spoolPage(int i) const;
+    QPainter * painter();
+    int pageCount() const;
+    QPair<int, QRectF> elementLocation(const QWebElement & e);
+private:
+    QWebPrinterPrivate * d;
+};
+#endif
+
 class QWEBKIT_EXPORT QWebFrame : public QObject {
     Q_OBJECT
     Q_PROPERTY(qreal textSizeMultiplier READ textSizeMultiplier WRITE setTextSizeMultiplier DESIGNABLE false)
@@ -228,6 +247,8 @@ private:
     friend class QWebPage;
     friend class QWebPagePrivate;
     friend class QWebFramePrivate;
+    friend class QWebPrinterPrivate;
+    friend class QWebPrinter;
     friend class DumpRenderTreeSupportQt;
     friend class WebCore::WidgetPrivate;
     friend class WebCore::FrameLoaderClientQt;
diff --git src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h
index 4108972..3698eed 100644
--- src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h
+++ src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h
@@ -35,6 +35,9 @@
 #include "wtf/RefPtr.h"
 #include "Frame.h"
 #include "ViewportArguments.h"
+#include <qpainter.h>
+#include "PrintContext.h"
+#include "GraphicsContext.h"
 
 #if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER)
 #include "texmap/TextureMapper.h"
@@ -69,6 +72,19 @@ public:
     int marginHeight;
 };
 
+class QWebPrinterPrivate {
+public:
+    WebCore::PrintContext printContext;
+    QPainter & painter;
+    const QWebFrame * frame;
+    WebCore::GraphicsContext graphicsContext;
+    int printWidth;
+    QHash<const WebCore::Node*, const WebCore::RenderObject *> elementToRenderObject;
+    
+    QWebPrinterPrivate(const QWebFrame * frame, QPaintDevice *printer, QPainter &p);
+    ~QWebPrinterPrivate();
+};
+
 class QWebFramePrivate {
 public:
     QWebFramePrivate()
diff --git src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp
index c1ef92e..dc4de39 100644
--- src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp
+++ src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp
@@ -75,8 +75,11 @@ public:
     QUrl userStyleSheetLocation;
     QString defaultTextEncoding;
     QString localStoragePath;
+    QString printingMediaType;
     QString offlineWebApplicationCachePath;
     qint64 offlineStorageDefaultQuota;
+    qreal printingMinimumShrinkFactor;
+    qreal printingMaximumShrinkFactor;
 
     void apply();
     WebCore::Settings* settings;
@@ -229,9 +232,18 @@ void QWebSettingsPrivate::apply()
         QString encoding = !defaultTextEncoding.isEmpty() ? defaultTextEncoding: global->defaultTextEncoding;
         settings->setDefaultTextEncodingName(encoding);
 
+        QString type = !printingMediaType.isEmpty() ? printingMediaType : global->printingMediaType;
+        settings->setPrintingMediaType(type.isEmpty() ? "print" : type);
+
         QString storagePath = !localStoragePath.isEmpty() ? localStoragePath : global->localStoragePath;
         settings->setLocalStorageDatabasePath(storagePath);
 
+        float minimumShrinkFactor = printingMinimumShrinkFactor > 0.0f ? printingMinimumShrinkFactor : global->printingMinimumShrinkFactor;
+        settings->setPrintingMinimumShrinkFactor(minimumShrinkFactor);
+
+        float maximumShrinkFactor = printingMaximumShrinkFactor > 0.0f ? printingMaximumShrinkFactor : global->printingMaximumShrinkFactor;
+        settings->setPrintingMaximumShrinkFactor(maximumShrinkFactor);
+
         value = attributes.value(QWebSettings::PrintElementBackgrounds,
                                       global->attributes.value(QWebSettings::PrintElementBackgrounds));
         settings->setShouldPrintBackgrounds(value);
@@ -519,6 +531,8 @@ QWebSettings::QWebSettings()
     d->attributes.insert(QWebSettings::SiteSpecificQuirksEnabled, true);
     d->offlineStorageDefaultQuota = 5 * 1024 * 1024;
     d->defaultTextEncoding = QLatin1String("iso-8859-1");
+    d->printingMinimumShrinkFactor = 1.25f;
+    d->printingMaximumShrinkFactor = 2.0f;
 }
 
 /*!
@@ -527,6 +541,8 @@ QWebSettings::QWebSettings()
 QWebSettings::QWebSettings(WebCore::Settings* settings)
     : d(new QWebSettingsPrivate(settings))
 {
+    d->printingMinimumShrinkFactor = 0.0f;
+    d->printingMaximumShrinkFactor = 0.0f;
     d->settings = settings;
     d->apply();
     allSettings()->append(d);
@@ -635,6 +651,86 @@ QString QWebSettings::defaultTextEncoding() const
 }
 
 /*!
+    \since 4.7
+    Specifies which media type to use when printing. If
+    left empty the default "print" will be used, other choices include "screen". 
+    See \l{http://www.w3.org/TR/CSS2/media.html}{CSS Standard}, for a complete list.
+
+    \sa printingMediaType()
+*/
+void QWebSettings::setPrintingMediaType(const QString& type)
+{
+    d->printingMediaType = type;
+    d->apply();
+}
+
+/*!
+    \since 4.7
+    Returns the media type used when printing or QString() if the
+    default value is used.
+
+    \sa setPrintingMediaType()
+*/
+QString QWebSettings::printingMediaType() const
+{
+    return d->printingMediaType;
+}
+
+/*!
+    \since 4.6
+    Specifies minimum shrink fator allowed for printing. If set to 0 a
+    default value is used.
+
+    When printing, content will be shrunk to reduce page usage, it
+    will reduced by a factor between printingMinimumShrinkFactor and
+    printingMaximumShrinkFactor. 
+
+    \sa printingMinimumShrinkFactor()
+    \sa setPrintingMaximumShrinkFactor()
+    \sa printingMaximumShrinkFactor()
+*/
+void QWebSettings::setPrintingMinimumShrinkFactor(qreal printingMinimumShrinkFactor)
+{
+    d->printingMinimumShrinkFactor = printingMinimumShrinkFactor;
+    d->apply();
+}
+
+/*!
+    \since 4.6
+    returns the minimum shrink factor used for printing.
+
+    \sa setPrintingMinimumShrinkFactor()
+*/
+qreal QWebSettings::printingMinimumShrinkFactor() const
+{
+    return d->printingMinimumShrinkFactor;
+}
+
+/*!
+    \since 4.6 
+    Specifies maximum shrink fator allowed for printing. If set to 0 a
+    default value is used.
+
+    \sa setPrintingMinimumShrinkFactor()
+*/
+void QWebSettings::setPrintingMaximumShrinkFactor(qreal printingMaximumShrinkFactor)
+{
+    d->printingMaximumShrinkFactor = printingMaximumShrinkFactor;
+    d->apply();
+}
+
+/*!
+    \since 4.6 
+    returns the maximum shrink factor used for printing.
+
+    \sa setPrintingMinimumShrinkFactor()
+*/
+qreal QWebSettings::printingMaximumShrinkFactor() const
+{
+    return d->printingMaximumShrinkFactor;
+}
+
+/*!
     Sets the path of the icon database to \a path. The icon database is used
     to store "favicons" associated with web sites.
 
diff --git src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h
index 008035b..bb134a3 100644
--- src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h
+++ src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h
@@ -116,6 +116,15 @@ public:
     void setDefaultTextEncoding(const QString &encoding);
     QString defaultTextEncoding() const;
 
+    void setPrintingMediaType(const QString &type);
+    QString printingMediaType() const;
+
+    void setPrintingMinimumShrinkFactor(qreal printingMinimumShrinkFactor);
+    qreal printingMinimumShrinkFactor() const;
+
+    void setPrintingMaximumShrinkFactor(qreal printingMaximimShrinkFactor);
+    qreal printingMaximumShrinkFactor() const;
+
     static void setIconDatabasePath(const QString &location);
     static QString iconDatabasePath();
     static void clearIconDatabase();
diff --git src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro
index 32798f7..5c6fd4f 100644
--- src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro
+++ src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro
@@ -2,7 +2,6 @@
 CONFIG += building-libs
 CONFIG += depend_includepath
 
-TARGET = QtWebKit
 TEMPLATE = lib
 
 DEFINES += BUILDING_WEBKIT
@@ -15,23 +14,53 @@ else: CONFIG_DIR = release
 
 SOURCE_DIR = $$replace(PWD, /WebKit/qt, "")
 
-include($$PWD/Api/headers.pri)
 include($$SOURCE_DIR/WebKit.pri)
-include($$SOURCE_DIR/JavaScriptCore/JavaScriptCore.pri)
+
+include($$SOURCE_DIR/JavaScriptCore/JavaScriptCore.pro)
+
+for(item, SOURCES):JAVASCRIPT_CORE_SOURCES += ../../JavaScriptCore/$$item
+
+unset(SOURCES)
+
+include($$SOURCE_DIR/WebCore/WebCore.pro)
+
+for(item, SOURCES): {
+    path = $$split(item, '/')
+
+    contains(path, sqlite3.c) {
+        WEB_CORE_SOURCES += $$item
+    }
+
+    !contains(path, sqlite3.c) {
+        WEB_CORE_SOURCES += ../../WebCore/$$item
+    }
+}
+for(item, HEADERS):WEB_CORE_HEADERS += ../../WebCore/$$item
+for(item, ASM_SOURCES):WEB_CORE_ASM_SOURCES += ../../WebCore/$$item
+
+SOURCES = $$JAVASCRIPT_CORE_SOURCES $$WEB_CORE_SOURCES
+HEADERS = $$WEB_CORE_HEADERS
+ASM_SOURCES = $$WEB_CORE_ASM_SOURCES
+
+mac {
+  for(item, OBJECTIVE_SOURCES):WEB_CORE_OBJECTIVE_SOURCES += ../../WebCore/$$item
+  OBJECTIVE_SOURCES = $$WEB_CORE_OBJECTIVE_SOURCES
+  INCLUDEPATH += ../../WebCore/platform/mac
+}
+
+include($$PWD/Api/headers.pri)
+
 webkit2 {
     include($$SOURCE_DIR/WebKit2/WebKit2.pri)
     include($$SOURCE_DIR/WebKit2/WebKit2API.pri)
 }
-include($$SOURCE_DIR/WebCore/WebCore.pri)
 
-!v8:prependJavaScriptCoreLib(../../JavaScriptCore)
-prependWebCoreLib(../../WebCore)
-webkit2:prependWebKit2Lib(../../WebKit2)
+TARGET = QtWebKit
 
 # This is needed for syncqt when it parses the dependencies on module's main pro file so
 # the generated includes are containing the dependencies.
 # It used to be in WebCore.pro but now that this is the main pro file it has to be here.
-QT += network
+QT += network gui
 
 isEmpty(OUTPUT_DIR): OUTPUT_DIR = ../..
 
@@ -42,6 +71,8 @@ win32*:!win32-msvc* {
     contains(DEFINES, ENABLE_WEBGL=1)|contains(CONFIG, texmap): LIBS += $$QMAKE_LIBS_OPENGL
 }
 
+win32-msvc*:LIBS += -lAdvapi32
+
 include_webinspector: RESOURCES += $$SOURCE_DIR/WebCore/inspector/front-end/WebKit.qrc $$WC_GENERATED_SOURCES_DIR/InspectorBackendStub.qrc
 
 # Extract sources to build from the generator definitions
diff --git src/corelib/tools/qtextboundaryfinder.cpp src/corelib/tools/qtextboundaryfinder.cpp
index e535151..db1e0e9 100644
--- src/corelib/tools/qtextboundaryfinder.cpp
+++ src/corelib/tools/qtextboundaryfinder.cpp
@@ -156,6 +156,8 @@ static void init(QTextBoundaryFinder::BoundaryType type, const QChar *chars, int
   \value NotAtBoundary  The boundary finder is not at a boundary position.
   \value StartWord  The boundary finder is at the start of a word.
   \value EndWord  The boundary finder is at the end of a word.
+  \value SoftHyphen The boundary finder is at the soft hyphen
+                    (can occur for a Line boundary type only).
 */
 
 /*!
@@ -369,7 +371,7 @@ int QTextBoundaryFinder::toNextBoundary()
         break;
     case Line:
         Q_ASSERT(pos);
-        while (pos < length && d->attributes[pos-1].lineBreakType < HB_Break)
+        while (pos < length && d->attributes[pos-1].lineBreakType == HB_NoBreak)
             ++pos;
         break;
     }
@@ -411,7 +413,7 @@ int QTextBoundaryFinder::toPreviousBoundary()
             --pos;
         break;
     case Line:
-        while (pos > 0 && d->attributes[pos-1].lineBreakType < HB_Break)
+        while (pos > 0 && d->attributes[pos-1].lineBreakType == HB_NoBreak)
             --pos;
         break;
     }
@@ -436,7 +438,7 @@ bool QTextBoundaryFinder::isAtBoundary() const
     case Word:
         return d->attributes[pos].wordBoundary;
     case Line:
-        return (pos > 0) ? d->attributes[pos-1].lineBreakType >= HB_Break : true;
+        return (pos > 0) ? d->attributes[pos-1].lineBreakType != HB_NoBreak : true;
     case Sentence:
         return d->attributes[pos].sentenceBoundary;
     }
@@ -452,6 +454,8 @@ QTextBoundaryFinder::BoundaryReasons QTextBoundaryFinder::boundaryReasons() cons
         return NotAtBoundary;
     if (! isAtBoundary())
         return NotAtBoundary;
+    if (t == Line && pos < length && d->attributes[pos-1].lineBreakType == HB_SoftHyphen)
+        return SoftHyphen;
     if (pos == 0) {
         if (d->attributes[pos].whiteSpace)
             return NotAtBoundary;
diff --git src/corelib/tools/qtextboundaryfinder.h src/corelib/tools/qtextboundaryfinder.h
index 7e28773..20891ae 100644
--- src/corelib/tools/qtextboundaryfinder.h
+++ src/corelib/tools/qtextboundaryfinder.h
@@ -71,8 +71,8 @@ public:
     enum BoundaryReason {
         NotAtBoundary = 0,
         StartWord = 1,
-        EndWord = 2
-        //Hyphen
+        EndWord = 2,
+        SoftHyphen = 4
     };
     Q_DECLARE_FLAGS( BoundaryReasons, BoundaryReason )
 
@@ -106,6 +106,8 @@ private:
     QTextBoundaryFinderPrivate *d;
 };
 
+Q_DECLARE_OPERATORS_FOR_FLAGS(QTextBoundaryFinder::BoundaryReasons)
+
 QT_END_NAMESPACE
 
 QT_END_HEADER
diff --git src/gui/gui.pro src/gui/gui.pro
index 63e3ccd..3dee2c8 100644
--- src/gui/gui.pro
+++ src/gui/gui.pro
@@ -87,6 +87,10 @@ win32:!contains(QT_CONFIG, directwrite) {
     DEFINES += QT_NO_DIRECTWRITE
 }
 
+win32-g++* {
+    INCLUDEPATH += $$PWD
+}
+
 mac:contains(QMAKE_MAC_XARCH, no) {
     DEFINES += QT_NO_MAC_XARCH
 } else {
diff --git src/gui/image/qpixmap.cpp src/gui/image/qpixmap.cpp
index 11d8535..3550817 100644
--- src/gui/image/qpixmap.cpp
+++ src/gui/image/qpixmap.cpp
@@ -134,12 +134,6 @@ extern QApplication::Type qt_appType;
 
 void QPixmap::init(int w, int h, int type)
 {
-    if (qt_appType == QApplication::Tty) {
-        qWarning("QPixmap: Cannot create a QPixmap when no GUI is being used");
-        data = 0;
-        return;
-    }
-
     if ((w > 0 && h > 0) || type == QPixmapData::BitmapType)
         data = QPixmapData::create(w, h, (QPixmapData::PixelType) type);
     else
diff --git src/gui/image/qpixmap_raster.cpp src/gui/image/qpixmap_raster.cpp
index 410aeaf..2436ce8 100644
--- src/gui/image/qpixmap_raster.cpp
+++ src/gui/image/qpixmap_raster.cpp
@@ -47,6 +47,7 @@
 #include "qnativeimage_p.h"
 #include "qimage_p.h"
 #include "qpaintengine.h"
+#include "kernel/qapplication_p.h"
 
 #include "qbitmap.h"
 #include "qimage.h"
@@ -115,8 +116,10 @@ void QRasterPixmapData::resize(int width, int height)
 #else
     if (pixelType() == BitmapType)
         format = QImage::Format_MonoLSB;
-    else
+    else if (qt_is_gui_used)
         format = QNativeImage::systemFormat();
+    else
+        format = QImage::Format_RGB32;
 #endif
 
     image = QImage(width, height, format);
@@ -432,7 +435,7 @@ void QRasterPixmapData::createPixmapForImage(QImage &sourceImage, Qt::ImageConve
                     ? QImage::Format_ARGB32_Premultiplied
                     : QImage::Format_RGB32;
         } else {
-            QImage::Format opaqueFormat = QNativeImage::systemFormat();
+            QImage::Format opaqueFormat = qt_is_gui_used ? QNativeImage::systemFormat() : QImage::Format_RGB32;
             QImage::Format alphaFormat = QImage::Format_ARGB32_Premultiplied;
 
 #if !defined(QT_HAVE_NEON) && !defined(QT_ALWAYS_HAVE_SSE2)
diff --git src/gui/kernel/qapplication_x11.cpp src/gui/kernel/qapplication_x11.cpp
index ba8bc1a..c743a1b 100644
--- src/gui/kernel/qapplication_x11.cpp
+++ src/gui/kernel/qapplication_x11.cpp
@@ -2282,6 +2282,8 @@ void qt_init(QApplicationPrivate *priv, int,
         QSegfaultHandler::initialize(priv->argv, priv->argc);
 #endif
         QCursorData::initialize();
+    } else if (!QApplicationPrivate::graphics_system_name.isNull()) {
+        QApplicationPrivate::graphics_system = QGraphicsSystemFactory::create(QApplicationPrivate::graphics_system_name);
     }
     QFont::initialize();
 
diff --git src/gui/kernel/qguiplatformplugin.cpp src/gui/kernel/qguiplatformplugin.cpp
index 16aa2a8..28706b5 100644
--- src/gui/kernel/qguiplatformplugin.cpp
+++ src/gui/kernel/qguiplatformplugin.cpp
@@ -85,7 +85,7 @@ QGuiPlatformPlugin *qt_guiPlatformPlugin()
 
         QString key = QString::fromLocal8Bit(qgetenv("QT_PLATFORM_PLUGIN"));
 #ifdef Q_WS_X11
-        if (key.isEmpty()) {
+        if (QApplication::type() != QApplication::Tty && key.isEmpty()) {
             switch(X11->desktopEnvironment) {
             case DE_KDE:
                 key = QString::fromLatin1("kde");
diff --git src/gui/kernel/qt_mac_p.h src/gui/kernel/qt_mac_p.h
index eced3a3..9234bdd 100644
--- src/gui/kernel/qt_mac_p.h
+++ src/gui/kernel/qt_mac_p.h
@@ -75,6 +75,62 @@
 
 #include <Carbon/Carbon.h>
 
+#if !defined(QT_MAC_USE_COCOA) && defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
+    // Some deprecated functions have been removed from the the 10.7 SDK, but the symbols are
+    // still exported by the 32-bit QD.framework (a subframework of ApplicationServices).
+    extern "C" {
+        // from QuickdrawAPI.h
+        // https://developer.apple.com/legacy/library/documentation/Carbon/reference/QuickDraw_Ref/QuickDraw_Ref.pdf
+        void          CopyBits(const BitMap *srcBits, const BitMap *dstBits, const Rect *srcRect, const Rect *dstRect, short mode, RgnHandle maskRgn);
+        void          CopyRgn(RgnHandle srcRgn, RgnHandle dstRgn);
+        void          DisposeRgn(RgnHandle rgn);
+        GDHandle      GetMainDevice(void);
+        const BitMap *GetPortBitMapForCopyBits(CGrafPtr port);
+        Rect         *GetRegionBounds(RgnHandle region, Rect *bounds);
+        RgnHandle     NewRgn(void);
+        OSStatus      QDRegionToRects(RgnHandle rgn, QDRegionParseDirection dir, RegionToRectsUPP proc, void *userData);
+        void          SetEmptyRgn(RgnHandle rgn);
+        void          SetRect(Rect* r, short left, short top, short right, short bottom);
+        void          SetRectRgn(RgnHandle rgn, short left, short top, short right, short bottom);
+        void          UnionRgn(RgnHandle srcRgnA, RgnHandle srcRgnB, RgnHandle dstRgn);
+        enum {
+            kQDRegionToRectsMsgInit       = 1,
+            kQDRegionToRectsMsgParse      = 2,
+            kQDRegionToRectsMsgTerminate  = 3
+        };
+        enum {
+            kQDParseRegionFromTop         = (1 << 0),
+            kQDParseRegionFromBottom      = (1 << 1),
+            kQDParseRegionFromLeft        = (1 << 2),
+            kQDParseRegionFromRight       = (1 << 3),
+            kQDParseRegionFromTopLeft     = kQDParseRegionFromTop | kQDParseRegionFromLeft,
+            kQDParseRegionFromBottomRight = kQDParseRegionFromBottom | kQDParseRegionFromRight
+        };
+
+        // from Fonts.h
+        // https://developer.apple.com/legacy/library/documentation/Carbon/reference/Font_Manager/fm_reference.pdf
+        OSStatus         FMCreateFontIterator(const FMFilter *iFilter, void *iRefCon, OptionBits iOptions, FMFontIterator *ioIterator);
+        OSStatus         FMDisposeFontIterator(FMFontIterator *ioIterator);
+        ATSFontFamilyRef FMGetATSFontFamilyRefFromFont(FMFontFamily iFamily);
+        ATSFontFamilyRef FMGetATSFontFamilyRefFromFontFamily(FMFontFamily iFamily);
+        ATSFontRef       FMGetATSFontRefFromFont(FMFont iFont);
+        OSStatus         FMGetFontFamilyInstanceFromFont(FMFont iFont, FMFontFamily *oFontFamily, FMFontStyle *oStyle);
+        FMFontFamily     FMGetFontFamilyFromATSFontFamilyRef(ATSFontFamilyRef iFamily);
+        FMFont           FMGetFontFromATSFontRef(ATSFontRef iFont);
+        OSStatus         FMGetFontFromFontFamilyInstance(FMFontFamily iFontFamily, FMFontStyle iStyle, FMFont *oFont, FMFontStyle *oIntrinsicStyle);
+        OSStatus         FMGetNextFont(FMFontIterator *ioIterator, FMFont *oFont);
+        enum {
+            kFMUseGlobalScopeOption       = 0x00000001
+        };
+        enum {
+            commandMark                   = 17,
+            checkMark                     = 18,
+            diamondMark                   = 19,
+            appleMark                     = 20
+        };
+    }
+#endif
+
 QT_BEGIN_NAMESPACE
 class QWidget;
 class QDragMoveEvent;
diff --git src/gui/painting/qpaintengine.h src/gui/painting/qpaintengine.h
index 27d6ac7..05beaf7 100644
--- src/gui/painting/qpaintengine.h
+++ src/gui/painting/qpaintengine.h
@@ -45,6 +45,7 @@
 #include <QtCore/qnamespace.h>
 #include <QtCore/qobjectdefs.h>
 #include <QtCore/qscopedpointer.h>
+#include <QtCore/qurl.h>
 #include <QtGui/qpainter.h>
 
 QT_BEGIN_HEADER
@@ -162,6 +163,19 @@ public:
     virtual void drawRects(const QRect *rects, int rectCount);
     virtual void drawRects(const QRectF *rects, int rectCount);
 
+    virtual void addHyperlink(const QRectF &r, const QUrl &url) {Q_UNUSED(r); Q_UNUSED(url);}
+    virtual void addAnchor(const QRectF &r, const QString &name) {Q_UNUSED(r); Q_UNUSED(name);}
+    virtual void addLink(const QRectF &r, const QString &anchor) {Q_UNUSED(r); Q_UNUSED(anchor);}
+    virtual void addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength) {
+        Q_UNUSED(r); Q_UNUSED(text); Q_UNUSED(name); Q_UNUSED(multiLine); Q_UNUSED(password); Q_UNUSED(readOnly); Q_UNUSED(maxLength);
+    }
+    virtual void addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly) {
+        Q_UNUSED(r); Q_UNUSED(checked); Q_UNUSED(name); Q_UNUSED(readOnly);
+    }
+    virtual void addRadioButton(const QRectF &r, const QString & group="", bool checked=false, const QString &name="", bool readOnly=false) {
+        Q_UNUSED(r); Q_UNUSED(checked); Q_UNUSED(name); Q_UNUSED(readOnly); Q_UNUSED(group);
+    }
+
     virtual void drawLines(const QLine *lines, int lineCount);
     virtual void drawLines(const QLineF *lines, int lineCount);
 
@@ -177,6 +191,10 @@ public:
     virtual void drawPolygon(const QPoint *points, int pointCount, PolygonDrawMode mode);
 
     virtual void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr) = 0;
+    virtual void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr, const QByteArray * data) {
+		Q_UNUSED(data);
+		drawPixmap(r,pm,sr);
+	}
     virtual void drawTextItem(const QPointF &p, const QTextItem &textItem);
     virtual void drawTiledPixmap(const QRectF &r, const QPixmap &pixmap, const QPointF &s);
     virtual void drawImage(const QRectF &r, const QImage &pm, const QRectF &sr,
diff --git src/gui/painting/qpaintengine_raster.cpp src/gui/painting/qpaintengine_raster.cpp
index f715c14..53ca273 100644
--- src/gui/painting/qpaintengine_raster.cpp
+++ src/gui/painting/qpaintengine_raster.cpp
@@ -2243,11 +2243,11 @@ namespace {
 /*!
     \reimp
 */
-void QRasterPaintEngine::drawImage(const QRectF &r, const QImage &img, const QRectF &sr,
+void QRasterPaintEngine::drawImage(const QRectF &r, const QImage &_img, const QRectF &_sr,
                                    Qt::ImageConversionFlags)
 {
 #ifdef QT_DEBUG_DRAW
-    qDebug() << " - QRasterPaintEngine::drawImage(), r=" << r << " sr=" << sr << " image=" << img.size() << "depth=" << img.depth();
+    qDebug() << " - QRasterPaintEngine::drawImage(), r=" << r << " sr=" << _sr << " image=" << _img.size() << "depth=" << img.depth();
 #endif
 
     if (r.isEmpty())
@@ -2255,6 +2255,17 @@ void QRasterPaintEngine::drawImage(const QRectF &r, const QImage &img, const QRe
 
     Q_D(QRasterPaintEngine);
     QRasterPaintEngineState *s = state();
+    
+    QImage img;
+    QRectF sr=_sr;
+    if (s->matrix.isAffine()) {
+        img = _img.copy(sr.toRect()).scaled(
+            s->matrix.mapRect(r).size().toSize(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+        sr = img.rect();
+    } else {
+        img=_img;
+    }
+ 
     int sr_l = qFloor(sr.left());
     int sr_r = qCeil(sr.right()) - 1;
     int sr_t = qFloor(sr.top());
diff --git src/gui/painting/qpainter.cpp src/gui/painting/qpainter.cpp
index 06477be..b42f277 100644
--- src/gui/painting/qpainter.cpp
+++ src/gui/painting/qpainter.cpp
@@ -5393,7 +5393,7 @@ void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm)
     }
 }
 
-void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
+void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr, const QByteArray * data)
 {
 #if defined QT_DEBUG_DRAW
     if (qt_show_painter_debug_output)
@@ -5518,7 +5518,7 @@ void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
             x += d->state->matrix.dx();
             y += d->state->matrix.dy();
         }
-        d->engine->drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh));
+        d->engine->drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh), data);
     }
 }
 
@@ -7254,6 +7254,200 @@ void QPainter::fillRect(const QRectF &r, const QColor &color)
     \since 4.5
 */
 
+
+/*!
+    \fn void QPainter::addAnchor(int x, int y, int w, int h, const QString &name);
+
+    \overload
+
+    Add an anchor to the current page at the rect specified by \a x, \a y, \a w and \a h  
+    named \a name.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addLink()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addAnchor(const QRect &r, const QString &name);
+
+    \overload
+
+    Add an anchor to the current page at the rect specified by \a r named \a name.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addLink()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void addAnchor(const QRectF &r, const QString &name);
+
+    \overload
+
+    Add an anchor to the current page at the rect specified by \a r named \a name.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addLink()
+
+    \since 4.7
+*/
+void QPainter::addAnchor(const QRectF &r, const QString &name)
+{
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addAnchor: Painter not active");
+        return;
+    }
+    d->engine->addAnchor(worldTransform().mapRect(r), name);
+}
+
+/*!
+    \fn void QPainter::addLink(int x, int y, int w, int h, const QString &anchor);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a x, \a y, \a w and \a h  
+    linking to the anchor named \a anchor.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addAnchor()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addLink(const QRect &r, const QString &anchor);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r  
+    linking to the anchor named \a anchor.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addAnchor()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addLink(const QRectF &r, const QString &anchor);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r  
+    linking to the anchor named \a anchor.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addAnchor()
+
+    \since 4.7
+*/
+void QPainter::addLink(const QRectF &r, const QString &anchor)
+{
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addLink: Painter not active");
+        return;
+    }
+    
+    d->engine->addLink(worldTransform().mapRect(r), anchor);
+}
+
+
+/*!
+    \fn void QPainter::addHyperlink(int x, int y, int w, int h, const QUrl &url);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a x, \a y, \a w and \a h  
+    linking to \a url.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addHyperlink(const QRect &r, const QUrl &url);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r
+    linking to \a url.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addHyperlink(const QRectF &r, const QUrl &url);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r
+    linking to \a url.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \since 4.7
+*/
+void QPainter::addHyperlink(const QRectF &r, const QUrl &url)
+{
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addHyperlink: Painter not active");
+        return;
+    }
+    d->engine->addHyperlink(worldTransform().mapRect(r), url);
+}
+
+void QPainter::addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength) {
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addTextField: Painter not active");
+        return;
+    }
+    d->engine->addTextField(worldTransform().mapRect(r), text, name, multiLine, password, readOnly, maxLength);
+}
+
+void QPainter::addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly) {
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addCheckBox: Painter not active");
+        return;
+    }
+    d->engine->addCheckBox(worldTransform().mapRect(r), checked, name, readOnly);
+}
+
+
+void QPainter::addRadioButton(const QRectF &r, const QString & group, bool checked, const QString &name, bool readOnly) {
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addRadioButton: Painter not active");
+        return;
+    }
+    d->engine->addRadioButton(worldTransform().mapRect(r), group, checked, name, readOnly);
+}
+
 /*!
     Sets the given render \a hint on the painter if \a on is true;
     otherwise clears the render hint.
diff --git src/gui/painting/qpainter.h src/gui/painting/qpainter.h
index 8efa2bd..b2cedb8 100644
--- src/gui/painting/qpainter.h
+++ src/gui/painting/qpainter.h
@@ -364,7 +364,7 @@ public:
     inline void drawPicture(const QPoint &p, const QPicture &picture);
 #endif
 
-    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect);
+    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect, const QByteArray * data=0);
     inline void drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect);
     inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
                            int sx, int sy, int sw, int sh);
@@ -447,6 +447,22 @@ public:
     inline void fillRect(const QRect &r, Qt::BrushStyle style);
     inline void fillRect(const QRectF &r, Qt::BrushStyle style);
 
+    inline void addAnchor(int x, int y, int w, int h, const QString &name);
+    inline void addAnchor(const QRect &r, const QString &name);
+    void addAnchor(const QRectF &r, const QString &name);
+
+    inline void addLink(int x, int y, int w, int h, const QString &anchor);
+    inline void addLink(const QRect &r, const QString &anchor);
+    void addLink(const QRectF &r, const QString &anchor);
+    
+    void addTextField(const QRectF &r, const QString &text="", const QString &name="", bool multiLine=false, bool password=false, bool readOnly=false, int maxLength=-1);
+    void addCheckBox(const QRectF &r, bool checked=false, const QString &name="", bool readOnly=false);
+    void addRadioButton(const QRectF &r, const QString & group="",  bool checked=false, const QString &name="", bool readOnly=false);;
+
+    inline void addHyperlink(int x, int y, int w, int h, const QUrl &url);
+    inline void addHyperlink(const QRect &r, const QUrl &url);
+    void addHyperlink(const QRectF &r, const QUrl &url);
+    
     void eraseRect(const QRectF &);
     inline void eraseRect(int x, int y, int w, int h);
     inline void eraseRect(const QRect &);
@@ -821,6 +837,35 @@ inline void QPainter::fillRect(const QRectF &r, Qt::BrushStyle style)
     fillRect(r, QBrush(style));
 }
 
+inline void QPainter::addAnchor(int x, int y, int w, int h, const QString &name) 
+{
+    addAnchor(QRectF(x, y, w, h), name);
+}
+
+inline void QPainter::addAnchor(const QRect &r, const QString &name)
+{
+    addAnchor(QRectF(r), name);
+}
+
+inline void QPainter::addLink(int x, int y, int w, int h, const QString &anchor)
+{
+    addLink(QRectF(x, y, w, h), anchor);
+}
+
+inline void QPainter::addLink(const QRect &r, const QString &anchor)
+{
+    addLink(QRectF(r), anchor);
+}
+
+inline void QPainter::addHyperlink(int x, int y, int w, int h, const QUrl &url)
+{
+    addHyperlink(QRectF(x, y, w, h), url);
+}
+
+inline void QPainter::addHyperlink(const QRect &r, const QUrl &url)
+{
+    addHyperlink(QRectF(r), url);
+}
 
 inline void QPainter::setBrushOrigin(int x, int y)
 {
diff --git src/gui/painting/qprintengine.h src/gui/painting/qprintengine.h
index 1c4f0aa..97bae58 100644
--- src/gui/painting/qprintengine.h
+++ src/gui/painting/qprintengine.h
@@ -90,6 +90,10 @@ public:
         PPK_SupportsMultipleCopies,
         PPK_PaperSize = PPK_PageSize,
 
+        PPK_UseCompression = 0xfe10,
+        PPK_ImageQuality,
+        PPK_ImageDPI,
+
         PPK_CustomBase = 0xff00
     };
 
@@ -97,6 +101,8 @@ public:
     virtual QVariant property(PrintEnginePropertyKey key) const = 0;
 
     virtual bool newPage() = 0;
+    virtual void beginSectionOutline(const QString &text, const QString &anchor) {Q_UNUSED(text); Q_UNUSED(anchor);}
+    virtual void endSectionOutline() {}
     virtual bool abort() = 0;
 
     virtual int metric(QPaintDevice::PaintDeviceMetric) const = 0;
diff --git src/gui/painting/qprintengine_pdf.cpp src/gui/painting/qprintengine_pdf.cpp
index b622611..4988df1 100644
--- src/gui/painting/qprintengine_pdf.cpp
+++ src/gui/painting/qprintengine_pdf.cpp
@@ -51,6 +51,7 @@
 #include <qimagewriter.h>
 #include <qbuffer.h>
 #include <qdatetime.h>
+#include <QCryptographicHash>
 
 #ifndef QT_NO_PRINTER
 #include <limits.h>
@@ -77,12 +78,6 @@ extern qint64 qt_image_id(const QImage &image);
 // Can't use it though, as gs generates completely wrong images if this is true.
 static const bool interpolateImages = false;
 
-#ifdef QT_NO_COMPRESS
-static const bool do_compress = false;
-#else
-static const bool do_compress = true;
-#endif
-
 QPdfPage::QPdfPage()
     : QPdf::ByteStream(true) // Enable file backing
 {
@@ -109,6 +104,30 @@ inline QPaintEngine::PaintEngineFeatures qt_pdf_decide_features()
     return f;
 }
 
+void QPdfEngine::setProperty(PrintEnginePropertyKey key, const QVariant &value) {
+    Q_D(QPdfEngine);
+    if (key==PPK_UseCompression)
+        d->doCompress = value.toBool();
+    else if (key==PPK_ImageQuality)
+        d->imageQuality = value.toInt();
+    else if (key==PPK_ImageDPI)
+        d->imageDPI = value.toInt();
+    else
+        QPdfBaseEngine::setProperty(key, value);
+}
+
+QVariant QPdfEngine::property(PrintEnginePropertyKey key) const {
+    Q_D(const QPdfEngine);
+    if (key==PPK_UseCompression)
+        return d->doCompress;
+    else if (key==PPK_ImageQuality)
+        return d->imageQuality;
+    else if (key==PPK_ImageDPI)
+        return d->imageDPI;
+    else
+        return QPdfBaseEngine::property(key);
+}
+
 QPdfEngine::QPdfEngine(QPrinter::PrinterMode m)
     : QPdfBaseEngine(*new QPdfEnginePrivate(m), qt_pdf_decide_features())
 {
@@ -156,6 +175,59 @@ bool QPdfEngine::begin(QPaintDevice *pdev)
 bool QPdfEngine::end()
 {
     Q_D(QPdfEngine);
+
+    uint dests;
+    if (d->anchors.size()) {
+        dests = d->addXrefEntry(-1);
+        d->xprintf("<<\n");
+        for (QHash<QString, uint>::iterator i=d->anchors.begin();
+             i != d->anchors.end(); ++i) {
+            d->printAnchor(i.key());
+            d->xprintf(" %d 0 R\n", i.value());
+        }
+        d->xprintf(">>\nendobj\n");
+    }
+
+    if (d->outlineRoot) {
+        d->outlineRoot->obj = d->requestObject();
+        d->writeOutlineChildren(d->outlineRoot);
+        d->addXrefEntry(d->outlineRoot->obj);
+        d->xprintf("<</Type /Outlines /First %d 0 R\n/Last %d 0 R>>\nendobj\n",
+                   d->outlineRoot->firstChild->obj, d->outlineRoot->lastChild->obj);
+    }
+
+    if (d->formFields.size()) {
+        uint font = d->addXrefEntry(-1);
+        d->xprintf("<</Type/Font/Name/Helv/BaseFont/Helvetica/Subtype/Type1>>\n"
+                   "endobj\n");
+        d->addXrefEntry(d->formFieldList);
+        d->xprintf("<</Fields[");
+        foreach(const uint & i, d->formFields)
+           d->xprintf("%d 0 R ",i);
+        d->xprintf("]\n"
+                   "/DR<</Font<</Helv %d 0 R>>>>\n"
+                   "/DA(/Helv 0 Tf 0 g)\n"
+                   ">>\n"
+                   "endobj\n", font);
+    }
+
+    d->catalog = d->addXrefEntry(-1);
+    d->xprintf("<<\n"
+               "/Type /Catalog\n"
+               "/Pages %d 0 R\n", d->pageRoot);
+    if (d->outlineRoot)
+        d->xprintf("/Outlines %d 0 R\n"
+                   "/PageMode /UseOutlines\n", d->outlineRoot->obj);
+
+    if (d->formFields.size())
+        d->xprintf("/AcroForm %d 0 R\n", d->formFieldList);
+
+    if (d->anchors.size())
+        d->xprintf("/Dests %d 0 R\n", dests);
+
+    d->xprintf(">>\n"
+               "endobj\n");
+
     d->writeTail();
 
     d->stream->unsetDevice();
@@ -165,8 +237,83 @@ bool QPdfEngine::end()
     return true;
 }
 
+void QPdfEngine::addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly) {
+    Q_D(QPdfEngine);
+    uint obj = d->addXrefEntry(-1);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    //Note that the pdf spec sayes that we should add some sort of default appearence atleast for yes, which we dont ghost script provides one, however acroread does not
+    if (d->formFieldList == -1) d->formFieldList = d->requestObject();
+    d->xprintf("<<\n"
+               "/Type /Annot\n"
+               "/Parrent %d 0 R\n"
+               "/Rect[", d->formFieldList);
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n"
+               "/FT/Btn\n"
+               "/Subtype/Widget\n"
+               "/P %d 0 R\n", d->pages.back());
+    if (checked)
+        d->xprintf("/AS /Yes\n");
+    if (!name.isEmpty()) {
+        d->xprintf("/T");
+        d->printString(name);
+        d->xprintf("\n");
+    }
+    d->xprintf("/Ff %d\n"
+               ">>\n"
+               "endobj\n",
+               (readOnly?1:0)<<0);
+    d->currentPage->annotations.push_back(obj);
+    d->formFields.push_back(obj);
+}
+
+void QPdfEngine::addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength)
+{
+    Q_D(QPdfEngine);
+    uint obj = d->addXrefEntry(-1);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    if (d->formFieldList == -1) d->formFieldList = d->requestObject();
+    d->xprintf("<<\n"
+               "/Type /Annot\n"
+               "/Parrent %d 0 R\n"
+               "/Rect[", d->formFieldList);
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n"
+               "/BS<</S/I>>\n"
+               "/FT/Tx\n"
+               "/Subtype/Widget\n"
+               "/P %d 0 R\n", d->pages.back());
+    if (!text.isEmpty()) {
+        d->xprintf("/V");
+        d->printString(text);
+        d->xprintf("\n");
+    }
+    if (!name.isEmpty()) {
+        d->xprintf("/T");
+        d->printString(name);
+        d->xprintf("\n");
+    }
+    if (maxLength >= 0)
+        d->xprintf("/MaxLen %d\n",maxLength);
+    d->xprintf("/DA(/Helv 12 Tf 0 g)\n"
+               "/Ff %d\n"
+               ">>\n"
+               "endobj\n",
+               (readOnly?1:0)<<0 | (password?1:0)<<13 | (multiLine?1:0)<<12
+        );
+    d->currentPage->annotations.push_back(obj);
+    d->formFields.push_back(obj);
+}
 
-void QPdfEngine::drawPixmap (const QRectF &rectangle, const QPixmap &pixmap, const QRectF &sr)
+void QPdfEngine::drawPixmap (const QRectF &rectangle, const QPixmap &pixmap, const QRectF &sr, const QByteArray * data)
 {
     if (sr.isEmpty() || rectangle.isEmpty() || pixmap.isNull())
         return;
@@ -176,22 +323,35 @@ void QPdfEngine::drawPixmap (const QRectF &rectangle, const QPixmap &pixmap, con
 
     QRect sourceRect = sr.toRect();
     QPixmap pm = sourceRect != pixmap.rect() ? pixmap.copy(sourceRect) : pixmap;
-    QImage image = pm.toImage();
+    QImage unscaled = pm.toImage();
+    QImage image = unscaled;
+
+    QRectF a = d->stroker.matrix.mapRect(rectangle);
+    QRectF c = d->paperRect();
+    int maxWidth = int(a.width() / c.width() * d->width() / 72.0 * d->imageDPI);
+    int maxHeight = int(a.height() / c.height() * d->height() / 72.0 * d->imageDPI);
+    if (image.width() > maxWidth || image.height() > maxHeight)
+        image = unscaled.scaled( image.size().boundedTo( QSize(maxWidth, maxHeight) ), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+
+    bool useScaled=true;
     bool bitmap = true;
-    const int object = d->addImage(image, &bitmap, pm.cacheKey());
+    const int object = d->addImage(image, &bitmap, pm.cacheKey(), &unscaled, (sr == pixmap.rect()?data:0), &useScaled );
+    int width = useScaled?image.width():unscaled.width();
+    int height = useScaled?image.height():unscaled.height();
+
     if (object < 0)
         return;
 
     *d->currentPage << "q\n/GSa gs\n";
     *d->currentPage
-        << QPdf::generateMatrix(QTransform(rectangle.width() / sr.width(), 0, 0, rectangle.height() / sr.height(),
+        << QPdf::generateMatrix(QTransform(rectangle.width() / width, 0, 0, rectangle.height() / height,
                                            rectangle.x(), rectangle.y()) * (d->simplePen ? QTransform() : d->stroker.matrix));
     if (bitmap) {
         // set current pen as d->brush
         d->brush = d->pen.brush();
     }
     setBrush();
-    d->currentPage->streamImage(image.width(), image.height(), object);
+    d->currentPage->streamImage(width, height, object);
     *d->currentPage << "Q\n";
 
     d->brush = b;
@@ -301,18 +461,68 @@ QPdfEnginePrivate::QPdfEnginePrivate(QPrinter::PrinterMode m)
     : QPdfBaseEnginePrivate(m)
 {
     streampos = 0;
-
+    doCompress = true;
+    imageDPI = 1400;
+    imageQuality = 94;
     stream = new QDataStream;
     pageOrder = QPrinter::FirstPageFirst;
     orientation = QPrinter::Portrait;
+    outlineRoot = NULL;
+    outlineCurrent = NULL;
     fullPage = false;
 }
 
 QPdfEnginePrivate::~QPdfEnginePrivate()
 {
+    if (outlineRoot)
+      delete outlineRoot;
     delete stream;
 }
 
+void QPdfEnginePrivate::printAnchor(const QString &name) {
+    QByteArray a = name.toUtf8();
+    if (a.size() >= 127)
+        a = QCryptographicHash::hash(a,QCryptographicHash::Sha1);
+    xprintf("/");
+    for (int i=0; i < a.size(); ++i) {
+        unsigned char c = a[i];
+        if (('a' <= c && c <= 'z') ||
+            ('A' <= c && c <= 'Z') ||
+            ('0' <= c && c <= '9') ||
+            c == '.' || c == '_')
+            xprintf("%c", c);
+        else if(c == 0)
+            xprintf("!");
+        else
+            xprintf("#%02x", c);
+    }
+}
+
+void QPdfEnginePrivate::writeOutlineChildren(OutlineItem * node) {
+    for (OutlineItem * i = node->firstChild; i != NULL; i = i->next)
+       i->obj = requestObject();
+    for (OutlineItem * i = node->firstChild; i != NULL; i = i->next) {
+       QPdfEnginePrivate::writeOutlineChildren(i);
+       addXrefEntry(i->obj);
+       xprintf("<</Title ");
+       printString(i->text);
+       xprintf("\n"
+               "  /Parent %d 0 R\n"
+               "  /Dest ", i->parent->obj);
+       printAnchor(i->anchor);
+       xprintf("\n  /Count 0\n");
+       if (i->next)
+           xprintf("  /Next %d 0 R\n", i->next->obj);
+       if (i->prev)
+           xprintf("  /Prev %d 0 R\n", i->prev->obj);
+       if (i->firstChild)
+           xprintf("  /First %d 0 R\n", i->firstChild->obj);
+       if (i->lastChild)
+           xprintf("  /Last %d 0 R\n", i->lastChild->obj);
+       xprintf(">>\n"
+               "endobj\n");
+    }
+}
 
 #ifdef USE_NATIVE_GRADIENTS
 int QPdfEnginePrivate::gradientBrush(const QBrush &b, const QMatrix &matrix, int *gStateObject)
@@ -398,7 +608,7 @@ int QPdfEnginePrivate::gradientBrush(const QBrush &b, const QMatrix &matrix, int
                 ">>\n"
                 "stream\n"
               << content
-              << "endstream\n"
+              << "\nendstream\n"
                 "endobj\n";
 
             int softMaskFormObject = addXrefEntry(-1);
@@ -520,10 +730,113 @@ int QPdfEnginePrivate::addBrushPattern(const QTransform &m, bool *specifyColor,
     return patternObj;
 }
 
+
+void QPdfEnginePrivate::convertImage(const QImage & image, QByteArray & imageData) {
+    int w = image.width();
+    int h = image.height();
+    imageData.resize(colorMode == QPrinter::GrayScale ? w * h : 3 * w * h);
+    uchar *data = (uchar *)imageData.data();
+    for (int y = 0; y < h; ++y) {
+        const QRgb *rgb = (const QRgb *)image.scanLine(y);
+        if (colorMode == QPrinter::GrayScale) {
+            for (int x = 0; x < w; ++x) {
+                *(data++) = qGray(*rgb);
+                ++rgb;
+            }
+        } else {
+            for (int x = 0; x < w; ++x) {
+                *(data++) = qRed(*rgb);
+                *(data++) = qGreen(*rgb);
+                *(data++) = qBlue(*rgb);
+                ++rgb;
+            }
+        }
+    }
+}
+
+#include <iostream>
+
+class jpg_header_reader {
+private:
+  const QByteArray * data;
+  int index;
+
+  class jpeg_exception {};
+
+  unsigned char next() {
+    if (index == data->size()) throw jpeg_exception();
+    return data->data()[index++];
+  }
+
+  void skip() {
+    int l = (next() << 8) + next();
+    if (l < 2) throw jpeg_exception();
+    for (int i=2; i < l; ++i) next();
+  }
+
+  void read_header() {
+    int l = (next() << 8) + next();
+    if (l < 2) throw jpeg_exception();
+    precision = next();
+    height = (next() << 8) + next();
+    width = (next() << 8) + next();
+    components = next();
+    if (l != 8 + components*3) throw jpeg_exception();
+  }
+
+public:
+  bool read(const QByteArray * d) {
+    index=0;
+    data=d;
+    try {
+      if (next() != 0xFF) throw jpeg_exception();
+      unsigned char marker = next();
+      if (marker != 0xD8) throw jpeg_exception();
+      while (true) {
+        marker = next();
+        while (marker != 0xFF) marker=next();
+        while (marker == 0xFF) marker=next();
+        switch(marker) {
+          case 0xC0:   // SOF0 Start Of Frame N - BaseLine
+          case 0xC1:   // SOF1 N indicates which compression process - Extended Sequential
+          case 0xC2:   // SOF2 Only SOF0-SOF2 are now in common use - Progressive
+          case 0xC3:   // SOF3 Lossless
+          case 0xC5:   // SOF5 Differential sequential
+          case 0xC6:   // SOF6 Differential progressive
+          case 0xC7:   // SOF7 Differential lossless
+          case 0xC9:   // SOF9 Extended sequential, arithmetic coding
+          case 0xCA:   // SOF10 Progressive, arithmetic coding
+          case 0xCB:   // SOF11 Lossless, arithmetic coding
+          case 0xCD:   // SOF13 Differential sequential, arithmetic coding
+          case 0xCE:   // SOF14 Differential progressive, arithmetic coding
+          case 0xCF:   // SOF15 Differential lossless, arithmetic coding
+          case 0xE1:   // EXIF/XMP Exif marker.  Also used for XMP data!
+            read_header();
+            return true;
+          case 0xDA:    // SOS Start Of Scan (begins compressed data)
+          case 0xD9:    // EOI End Of Image (end of datastream)
+            return false;
+          default:
+            skip();
+            break;
+          }
+        }
+    } catch(jpeg_exception) {
+      return false;
+    }
+    return true;
+  }
+
+  int precision, height, width, components;
+
+};
+
+
+
 /*!
  * Adds an image to the pdf and return the pdf-object id. Returns -1 if adding the image failed.
  */
-int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_no)
+int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_no, const QImage * noneScaled, const QByteArray * data, bool * useScaled)
 {
     if (img.isNull())
         return -1;
@@ -564,65 +877,100 @@ int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_n
         }
         object = writeImage(data, w, h, d, 0, 0);
     } else {
-        QByteArray softMaskData;
-        bool dct = false;
         QByteArray imageData;
-        bool hasAlpha = false;
-        bool hasMask = false;
+        uLongf target=1024*1024*1024;
+        bool uns=false;
+        bool dct = false;
+
+        d = (colorMode == QPrinter::GrayScale) ? 8 : 32;
 
         if (QImageWriter::supportedImageFormats().contains("jpeg") && colorMode != QPrinter::GrayScale) {
-            QBuffer buffer(&imageData);
+            QByteArray imageData2;
+
+            QBuffer buffer(&imageData2);
             QImageWriter writer(&buffer, "jpeg");
-            writer.setQuality(94);
+            writer.setQuality(imageQuality);
             writer.write(image);
-            dct = true;
-
-            if (format != QImage::Format_RGB32) {
-                softMaskData.resize(w * h);
-                uchar *sdata = (uchar *)softMaskData.data();
-                for (int y = 0; y < h; ++y) {
-                    const QRgb *rgb = (const QRgb *)image.scanLine(y);
-                    for (int x = 0; x < w; ++x) {
-                        uchar alpha = qAlpha(*rgb);
-                        *sdata++ = alpha;
-                        hasMask |= (alpha < 255);
-                        hasAlpha |= (alpha != 0 && alpha != 255);
-                        ++rgb;
-                    }
-                }
+
+            if ((uLongf)imageData2.size() < target) {
+                imageData=imageData2;
+                target = imageData2.size();
+                dct = true;
+                uns=false;
             }
-        } else {
-            imageData.resize(colorMode == QPrinter::GrayScale ? w * h : 3 * w * h);
-            uchar *data = (uchar *)imageData.data();
+        }
+
+        if (noneScaled && noneScaled->rect() != image.rect()) {
+            QByteArray imageData2;
+            if (noneScaled->format() != QImage::Format_RGB32 && noneScaled->format() != QImage::Format_ARGB32)
+                convertImage(noneScaled->convertToFormat(QImage::Format_ARGB32), imageData2);
+            else
+                convertImage(*noneScaled, imageData2);
+            uLongf len = imageData2.size();
+            uLongf destLen = len + len/100 + 13; // zlib requirement
+            Bytef* dest = new Bytef[destLen];
+            if (Z_OK == ::compress(dest, &destLen, (const Bytef*) imageData2.data(), (uLongf)len) &&
+                (uLongf)destLen < target) {
+                imageData=imageData2;
+                target=destLen;
+                dct=false;
+                uns=true;
+            }
+            delete[] dest;
+        }
+
+        {
+            QByteArray imageData2;
+            convertImage(image, imageData2);
+            uLongf len = imageData2.size();
+            uLongf destLen = len + len/100 + 13; // zlib requirement
+            Bytef* dest = new Bytef[destLen];
+            if (Z_OK == ::compress(dest, &destLen, (const Bytef*) imageData2.data(), (uLongf)len) &&
+                (uLongf)destLen < target) {
+                imageData=imageData2;
+                target=destLen;
+                dct=false;
+                uns=false;
+            }
+            delete[] dest;
+        }
+
+
+        if (colorMode != QPrinter::GrayScale && noneScaled != 0 && data != 0) {
+          jpg_header_reader header;
+          if (header.read(data)) {
+            d = header.components == 3?32:8;
+            imageData = *data;
+            target=data->size();
+            dct=true;
+            uns=true;
+          }
+        }
+
+        if (uns) {
+            w = noneScaled->width();
+            h = noneScaled->height();
+        }
+        if (useScaled) *useScaled = (uns?false:true);
+        QByteArray softMaskData;
+        bool hasAlpha = false;
+        bool hasMask = false;
+
+        if ((!uns && format == QImage::Format_ARGB32) || (uns && noneScaled->format() == QImage::Format_ARGB32)) {
             softMaskData.resize(w * h);
             uchar *sdata = (uchar *)softMaskData.data();
             for (int y = 0; y < h; ++y) {
-                const QRgb *rgb = (const QRgb *)image.scanLine(y);
-                if (colorMode == QPrinter::GrayScale) {
-                    for (int x = 0; x < w; ++x) {
-                        *(data++) = qGray(*rgb);
-                        uchar alpha = qAlpha(*rgb);
-                        *sdata++ = alpha;
-                        hasMask |= (alpha < 255);
-                        hasAlpha |= (alpha != 0 && alpha != 255);
-                        ++rgb;
-                    }
-                } else {
-                    for (int x = 0; x < w; ++x) {
-                        *(data++) = qRed(*rgb);
-                        *(data++) = qGreen(*rgb);
-                        *(data++) = qBlue(*rgb);
-                        uchar alpha = qAlpha(*rgb);
-                        *sdata++ = alpha;
-                        hasMask |= (alpha < 255);
-                        hasAlpha |= (alpha != 0 && alpha != 255);
-                        ++rgb;
-                    }
+                const QRgb *rgb = (const QRgb *)(uns?noneScaled->scanLine(y):image.scanLine(y));
+                for (int x = 0; x < w; ++x) {
+                    uchar alpha = qAlpha(*rgb);
+                    *sdata++ = alpha;
+                    hasMask |= (alpha < 255);
+                    hasAlpha |= (alpha != 0 && alpha != 255);
+                    ++rgb;
                 }
             }
-            if (format == QImage::Format_RGB32)
-                hasAlpha = hasMask = false;
         }
+
         int maskObject = 0;
         int softMaskObject = 0;
         if (hasAlpha) {
@@ -644,7 +992,7 @@ int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_n
             }
             maskObject = writeImage(mask, w, h, 1, 0, 0);
         }
-        object = writeImage(imageData, w, h, colorMode == QPrinter::GrayScale ? 8 : 32,
+        object = writeImage(imageData, w, h, d,
                             maskObject, softMaskObject, dct);
     }
     imageCache.insert(serial_no, object);
@@ -758,7 +1106,7 @@ void QPdfEnginePrivate::xprintf(const char* fmt, ...)
 int QPdfEnginePrivate::writeCompressed(QIODevice *dev)
 {
 #ifndef QT_NO_COMPRESS
-    if (do_compress) {
+    if (doCompress) {
         int size = QPdfPage::chunkSize();
         int sum = 0;
         ::z_stream zStruct;
@@ -832,7 +1180,7 @@ int QPdfEnginePrivate::writeCompressed(QIODevice *dev)
 int QPdfEnginePrivate::writeCompressed(const char *src, int len)
 {
 #ifndef QT_NO_COMPRESS
-    if(do_compress) {
+    if(doCompress) {
         uLongf destLen = len + len/100 + 13; // zlib requirement
         Bytef* dest = new Bytef[destLen];
         if (Z_OK == ::compress(dest, &destLen, (const Bytef*) src, (uLongf)len)) {
@@ -885,13 +1233,13 @@ int QPdfEnginePrivate::writeImage(const QByteArray &data, int width, int height,
         write(data);
         len = data.length();
     } else {
-        if (do_compress)
+        if (doCompress)
             xprintf("/Filter /FlateDecode\n>>\nstream\n");
         else
             xprintf(">>\nstream\n");
         len = writeCompressed(data);
     }
-    xprintf("endstream\n"
+    xprintf("\nendstream\n"
             "endobj\n");
     addXrefEntry(lenobj);
     xprintf("%d\n"
@@ -908,14 +1256,9 @@ void QPdfEnginePrivate::writeHeader()
 
     writeInfo();
 
-    catalog = addXrefEntry(-1);
     pageRoot = requestObject();
-    xprintf("<<\n"
-            "/Type /Catalog\n"
-            "/Pages %d 0 R\n"
-            ">>\n"
-            "endobj\n", pageRoot);
 
+    formFieldList = -1;
     // graphics state
     graphicsState = addXrefEntry(-1);
     xprintf("<<\n"
@@ -944,16 +1287,25 @@ void QPdfEnginePrivate::writeInfo()
     printString(creator);
     xprintf("\n/Producer ");
     printString(QString::fromLatin1("Qt " QT_VERSION_STR));
-    QDateTime now = QDateTime::currentDateTime().toUTC();
+    QDateTime now = QDateTime::currentDateTime();
     QTime t = now.time();
     QDate d = now.date();
-    xprintf("\n/CreationDate (D:%d%02d%02d%02d%02d%02d)\n",
+    xprintf("\n/CreationDate (D:%d%02d%02d%02d%02d%02d",
             d.year(),
             d.month(),
             d.day(),
             t.hour(),
             t.minute(),
             t.second());
+    QDateTime fake=now;
+    fake.setTimeSpec(Qt::UTC);
+    int offset = now.secsTo(fake);
+    if (offset == 0)
+        xprintf("Z)\n");
+    else if (offset < 0)
+        xprintf("-%02d'%02d')\n", (-offset)/60/60 , ((-offset)/60) % 60);
+    else if (offset > 0)
+        xprintf("+%02d'%02d')\n", offset/60/60 , (offset/60) % 60);
     xprintf(">>\n"
             "endobj\n");
 }
@@ -1027,7 +1379,7 @@ void QPdfEnginePrivate::embedFont(QFontSubset *font)
             "/CapHeight " << properties.capHeight.toReal()*scale << "\n"
             "/StemV " << properties.lineWidth.toReal()*scale << "\n"
             "/FontFile2 " << fontstream << "0 R\n"
-            ">> endobj\n";
+            ">>\nendobj\n";
         write(descriptor);
     }
     {
@@ -1039,13 +1391,13 @@ void QPdfEnginePrivate::embedFont(QFontSubset *font)
         s << "<<\n"
             "/Length1 " << fontData.size() << "\n"
             "/Length " << length_object << "0 R\n";
-        if (do_compress)
+        if (doCompress)
             s << "/Filter /FlateDecode\n";
         s << ">>\n"
             "stream\n";
         write(header);
         int len = writeCompressed(fontData);
-        write("endstream\n"
+        write("\nendstream\n"
               "endobj\n");
         addXrefEntry(length_object);
         xprintf("%d\n"
@@ -1072,7 +1424,7 @@ void QPdfEnginePrivate::embedFont(QFontSubset *font)
         xprintf("<< /Length %d >>\n"
                 "stream\n", touc.length());
         write(touc);
-        write("endstream\n"
+        write("\nendstream\n"
               "endobj\n");
     }
     {
@@ -1101,6 +1453,101 @@ void QPdfEnginePrivate::writeFonts()
     fonts.clear();
 }
 
+
+void QPdfEngine::addHyperlink(const QRectF &r, const QUrl &url)
+{
+    Q_D(QPdfEngine);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    uint annot = d->addXrefEntry(-1);
+    QByteArray urlascii = url.toString().toLatin1();
+    int len = urlascii.size();
+    char *url_esc = new char[len * 2 + 1];
+    const char * urldata = urlascii.constData();
+    int k = 0;
+    for (int j = 0; j < len; j++, k++){
+        if (urldata[j] == '(' ||
+            urldata[j] == ')' ||
+            urldata[j] == '\\'){
+            url_esc[k] = '\\';
+            k++;
+        }
+        url_esc[k] = urldata[j];
+    }
+    url_esc[k] = 0;
+    d->xprintf("<<\n/Type /Annot\n/Subtype /Link\n/Rect [");
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n/Border [0 0 0]\n/A <<\n");
+    d->xprintf("/Type /Action\n/S /URI\n/URI (%s)\n", url_esc);
+    d->xprintf(">>\n>>\n");
+    d->xprintf("endobj\n");
+    d->currentPage->annotations.append(annot);
+    delete[] url_esc;
+}
+
+void QPdfEngine::addLink(const QRectF &r, const QString &anchor)
+{
+    Q_D(QPdfEngine);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    uint annot = d->addXrefEntry(-1);
+    d->xprintf("<<\n/Type /Annot\n/Subtype /Link\n/Rect [");
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n/Border [0 0 0]\n/Dest ");
+    d->printAnchor(anchor);
+    d->xprintf("\n>>\n");
+    d->xprintf("endobj\n");
+    d->currentPage->annotations.append(annot);
+}
+
+void QPdfEngine::addAnchor(const QRectF &r, const QString &name)
+{
+    Q_D(QPdfEngine);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    uint anchor = d->addXrefEntry(-1);
+    d->xprintf("[%d /XYZ %s \n",
+               d->pages.size() - 1,
+               qt_real_to_string(rr.left(), buf));
+    d->xprintf("%s 0]\n",
+               qt_real_to_string(rr.bottom(), buf));
+    d->xprintf("endobj\n");
+    d->anchors[name] = anchor;
+}
+
+void QPdfEngine::beginSectionOutline(const QString &text, const QString &anchor)
+{
+    Q_D(QPdfEngine);
+    if (d->outlineCurrent == NULL) {
+        if (d->outlineRoot)
+            delete d->outlineRoot;
+        d->outlineCurrent = d->outlineRoot = new QPdfEnginePrivate::OutlineItem(QString(), QString());
+    }
+
+    QPdfEnginePrivate::OutlineItem *i = new QPdfEnginePrivate::OutlineItem(text, anchor);
+    i->parent = d->outlineCurrent;
+    i->prev = d->outlineCurrent->lastChild;
+    if (d->outlineCurrent->firstChild)
+        d->outlineCurrent->lastChild->next = i;
+    else
+        d->outlineCurrent->firstChild = i;
+    d->outlineCurrent->lastChild = i;
+    d->outlineCurrent = i;
+}
+
+void QPdfEngine::endSectionOutline()
+{
+    Q_D(QPdfEngine);
+    if (d->outlineCurrent)
+        d->outlineCurrent = d->outlineCurrent->parent;
+}
+
 void QPdfEnginePrivate::writePage()
 {
     if (pages.empty())
@@ -1171,14 +1618,14 @@ void QPdfEnginePrivate::writePage()
     addXrefEntry(pageStream);
     xprintf("<<\n"
             "/Length %d 0 R\n", pageStreamLength); // object number for stream length object
-    if (do_compress)
+    if (doCompress)
         xprintf("/Filter /FlateDecode\n");
 
     xprintf(">>\n");
     xprintf("stream\n");
     QIODevice *content = currentPage->stream();
     int len = writeCompressed(content);
-    xprintf("endstream\n"
+    xprintf("\nendstream\n"
             "endobj\n");
 
     addXrefEntry(pageStreamLength);
diff --git src/gui/painting/qprintengine_pdf_p.h src/gui/painting/qprintengine_pdf_p.h
index 7dea801..1e922df 100644
--- src/gui/painting/qprintengine_pdf_p.h
+++ src/gui/painting/qprintengine_pdf_p.h
@@ -92,7 +92,12 @@ public:
     // reimplementations QPaintEngine
     bool begin(QPaintDevice *pdev);
     bool end();
-    void drawPixmap (const QRectF & rectangle, const QPixmap & pixmap, const QRectF & sr);
+
+    void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr, const QByteArray * data=0);
+    void drawPixmap(const QRectF & rectangle, const QPixmap & pixmap, const QRectF & sr) {
+        drawPixmap(rectangle, pixmap, sr, 0);
+    }
+
     void drawImage(const QRectF &r, const QImage &pm, const QRectF &sr,
                    Qt::ImageConversionFlags flags = Qt::AutoColor);
     void drawTiledPixmap (const QRectF & rectangle, const QPixmap & pixmap, const QPointF & point);
@@ -108,12 +113,23 @@ public:
 
     void setBrush();
 
+    virtual void addHyperlink(const QRectF &r, const QUrl &url);
+    virtual void addAnchor(const QRectF &r, const QString &name);
+    virtual void addLink(const QRectF &r, const QString &anchor);
+    virtual void addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength);
+    virtual void addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly);
+
     // ### unused, should have something for this in QPrintEngine
     void setAuthor(const QString &author);
     QString author() const;
 
     void setDevice(QIODevice* dev);
 
+    void beginSectionOutline(const QString &text, const QString &anchor);
+    void endSectionOutline();
+
+    void setProperty(PrintEnginePropertyKey key, const QVariant &value);
+    QVariant property(PrintEnginePropertyKey key) const;
 private:
     Q_DISABLE_COPY(QPdfEngine)
 
@@ -124,6 +140,35 @@ class QPdfEnginePrivate : public QPdfBaseEnginePrivate
 {
     Q_DECLARE_PUBLIC(QPdfEngine)
 public:
+  
+    class OutlineItem {
+    public:
+        OutlineItem *parent;
+        OutlineItem *next;
+        OutlineItem *prev;
+        OutlineItem *firstChild;
+        OutlineItem *lastChild;
+        uint obj;
+        QString text;
+        QString anchor;
+        
+        OutlineItem(const QString &t, const QString &a): 
+            parent(NULL), next(NULL), prev(NULL), firstChild(NULL), lastChild(NULL),
+            obj(0), text(t), anchor(a) {}
+        ~OutlineItem() {
+            OutlineItem *i = firstChild;
+            while(i != NULL) { 
+                OutlineItem *n = i->next;
+                delete i;
+                i=n;
+            }
+        }
+    };
+    
+    OutlineItem *outlineRoot;
+    OutlineItem *outlineCurrent;
+    void writeOutlineChildren(OutlineItem *node);
+    
     QPdfEnginePrivate(QPrinter::PrinterMode m);
     ~QPdfEnginePrivate();
 
@@ -141,7 +186,9 @@ public:
     void writeHeader();
     void writeTail();
 
-    int addImage(const QImage &image, bool *bitmap, qint64 serial_no);
+    void convertImage(const QImage & image, QByteArray & imageData);
+
+    int addImage(const QImage &image, bool *bitmap, qint64 serial_no, const QImage * noneScaled=0, const QByteArray * data=0, bool * useScaled=0);
     int addConstantAlphaObject(int brushAlpha, int penAlpha = 255);
     int addBrushPattern(const QTransform &matrix, bool *specifyColor, int *gStateObject);
 
@@ -161,16 +208,25 @@ private:
     void writeFonts();
     void embedFont(QFontSubset *font);
 
+    int formFieldList;
+    QVector<uint> formFields;
     QVector<int> xrefPositions;
     QDataStream* stream;
     int streampos;
 
+    bool doCompress;
+    int imageDPI;
+    int imageQuality;
+
     int writeImage(const QByteArray &data, int width, int height, int depth,
                    int maskObject, int softMaskObject, bool dct = false);
     void writePage();
 
     int addXrefEntry(int object, bool printostr = true);
+
     void printString(const QString &string);
+    void printAnchor(const QString &name);
+    
     void xprintf(const char* fmt, ...);
     inline void write(const QByteArray &data) {
         stream->writeRawData(data.constData(), data.size());
@@ -183,6 +239,8 @@ private:
 
     // various PDF objects
     int pageRoot, catalog, info, graphicsState, patternColorSpace;
+    QVector<uint> dests;
+    QHash<QString, uint> anchors;
     QVector<uint> pages;
     QHash<qint64, uint> imageCache;
     QHash<QPair<uint, uint>, uint > alphaCache;
diff --git src/gui/painting/qprinter.cpp src/gui/painting/qprinter.cpp
index 2fffbef..7211042 100644
--- src/gui/painting/qprinter.cpp
+++ src/gui/painting/qprinter.cpp
@@ -933,6 +933,39 @@ void QPrinter::setOutputFileName(const QString &fileName)
     d->addToManualSetList(QPrintEngine::PPK_OutputFileName);
 }
 
+/*!
+    Add a section to the document outline. All following sections will be added
+    to as subsections to this section, until endSectionOutline() has been called.
+
+    \a name is the name of the added section. \a anchor is the name of an anchor
+    indicating the beginning of the section.  This anchor must be added by calling
+    QPainter::addAnchor().
+
+    Note that for output formats not supporting outlines, currently all other then PDF,
+    this call has no effect.
+
+    \sa endSectionOutline() QPainter::addAnchor() 
+
+    \since 4.7
+*/
+void QPrinter::beginSectionOutline(const QString &name, const QString &anchor)
+{
+    Q_D(QPrinter);
+    d->printEngine->beginSectionOutline(name, anchor);
+}
+
+/*!
+    End the current section.
+
+    \sa beginSectionOutline()
+
+    \since 4.7
+*/
+void QPrinter::endSectionOutline() 
+{
+    Q_D(QPrinter);
+    d->printEngine->endSectionOutline();
+}
 
 /*!
   Returns the name of the program that sends the print output to the
diff --git src/gui/painting/qprinter.h src/gui/painting/qprinter.h
index ce2adf3..9cdba39 100644
--- src/gui/painting/qprinter.h
+++ src/gui/painting/qprinter.h
@@ -147,6 +147,9 @@ public:
     enum PrinterOption { PrintToFile, PrintSelection, PrintPageRange };
 #endif // QT3_SUPPORT
 
+    void beginSectionOutline(const QString &text, const QString &anchor);
+    void endSectionOutline();
+
     void setOutputFormat(OutputFormat format);
     OutputFormat outputFormat() const;
 
diff --git src/gui/styles/qstyle.cpp src/gui/styles/qstyle.cpp
index 81959c2..1ae9ef2 100644
--- src/gui/styles/qstyle.cpp
+++ src/gui/styles/qstyle.cpp
@@ -47,6 +47,7 @@
 #include "qpixmapcache.h"
 #include "qstyleoption.h"
 #include "private/qstyle_p.h"
+#include "private/qapplication_p.h"
 #ifndef QT_NO_DEBUG
 #include "qdebug.h"
 #endif
@@ -2231,7 +2232,7 @@ QPalette QStyle::standardPalette() const
 {
 #ifdef Q_WS_X11
     QColor background;
-    if (QX11Info::appDepth() > 8)
+    if (!qt_is_gui_used || QX11Info::appDepth() > 8)
         background = QColor(0xd4, 0xd0, 0xc8); // win 2000 grey
     else
         background = QColor(192, 192, 192);
diff --git src/gui/text/qfontengine_coretext.mm src/gui/text/qfontengine_coretext.mm
index 0a3d263..9cd2699 100644
--- src/gui/text/qfontengine_coretext.mm
+++ src/gui/text/qfontengine_coretext.mm
@@ -831,7 +831,13 @@ void QCoreTextFontEngine::recalcAdvances(QGlyphLayout *glyphs, QTextEngine::Shap
 
 QFontEngine::FaceId QCoreTextFontEngine::faceId() const
 {
-    return QFontEngine::FaceId();
+    FaceId result;
+    result.index = 0;
+
+    QCFString name = CTFontCopyName(ctfont, kCTFontUniqueNameKey);
+    result.filename = QCFString::toQString(name).toUtf8();
+
+    return result;
 }
 
 bool QCoreTextFontEngine::canRender(const QChar *string, int len)
@@ -856,9 +862,26 @@ bool QCoreTextFontEngine::getSfntTableData(uint tag, uchar *buffer, uint *length
     return true;
 }
 
-void QCoreTextFontEngine::getUnscaledGlyph(glyph_t, QPainterPath *, glyph_metrics_t *)
+void QCoreTextFontEngine::getUnscaledGlyph(glyph_t glyph, QPainterPath *path, glyph_metrics_t *metric)
 {
-    // ###
+    CGAffineTransform cgMatrix = CGAffineTransformIdentity;
+
+    qreal emSquare = CTFontGetUnitsPerEm(ctfont);
+    qreal scale = emSquare / CTFontGetSize(ctfont);
+    cgMatrix = CGAffineTransformScale(cgMatrix, scale, -scale);
+
+    QCFType<CGPathRef> cgpath = CTFontCreatePathForGlyph(ctfont, (CGGlyph) glyph, &cgMatrix);
+    ConvertPathInfo info(path, QPointF(0,0));
+    CGPathApply(cgpath, &info, convertCGPathToQPainterPath);
+
+    *metric = boundingBox(glyph);
+    // scale the metrics too
+    metric->width  = QFixed::fromReal(metric->width.toReal() * scale);
+    metric->height = QFixed::fromReal(metric->height.toReal() * scale);
+    metric->x      = QFixed::fromReal(metric->x.toReal() * scale);
+    metric->y      = QFixed::fromReal(metric->y.toReal() * scale);
+    metric->xoff   = QFixed::fromReal(metric->xoff.toReal() * scale);
+    metric->yoff   = QFixed::fromReal(metric->yoff.toReal() * scale);
 }
 
 QFixed QCoreTextFontEngine::emSquareSize() const
@@ -875,6 +898,45 @@ QFontEngine *QCoreTextFontEngine::cloneWithSize(qreal pixelSize) const
     return new QCoreTextFontEngine(cgFont, newFontDef);
 }
 
+QFontEngine::Properties QCoreTextFontEngine::properties() const
+{
+    Properties result;
+
+    QCFString psName, copyright;
+    psName = CTFontCopyPostScriptName(ctfont);
+    copyright = CTFontCopyName(ctfont, kCTFontCopyrightNameKey);
+    result.postscriptName = QCFString::toQString(psName).toUtf8();
+    result.copyright = QCFString::toQString(copyright).toUtf8();
+
+    qreal emSquare = CTFontGetUnitsPerEm(ctfont);
+    qreal scale = emSquare / CTFontGetSize(ctfont);
+
+    CGRect cgRect = CTFontGetBoundingBox(ctfont);
+    result.boundingBox = QRectF(cgRect.origin.x * scale,
+                                -CTFontGetAscent(ctfont) * scale,
+                                cgRect.size.width * scale,
+                                cgRect.size.height * scale);
+
+    result.emSquare = emSquareSize();
+    result.ascent = QFixed::fromReal(CTFontGetAscent(ctfont) * scale);
+    result.descent = QFixed::fromReal(CTFontGetDescent(ctfont) * scale);
+    result.leading = QFixed::fromReal(CTFontGetLeading(ctfont) * scale);
+    result.italicAngle = QFixed::fromReal(CTFontGetSlantAngle(ctfont));
+    result.capHeight = QFixed::fromReal(CTFontGetCapHeight(ctfont) * scale);
+    result.lineWidth = QFixed::fromReal(CTFontGetUnderlineThickness(ctfont) * scale);
+
+    if (fontDef.styleStrategy & QFont::ForceIntegerMetrics) {
+        result.ascent = result.ascent.round();
+        result.descent = result.descent.round();
+        result.leading = result.leading.round();
+        result.italicAngle = result.italicAngle.round();
+        result.capHeight = result.capHeight.round();
+        result.lineWidth = result.lineWidth.round();
+    }
+
+    return result;
+}
+
 QT_END_NAMESPACE
 
 #endif// !defined(Q_WS_MAC) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
diff --git src/gui/text/qfontengine_coretext_p.h src/gui/text/qfontengine_coretext_p.h
index 73d9754..f0939fd 100644
--- src/gui/text/qfontengine_coretext_p.h
+++ src/gui/text/qfontengine_coretext_p.h
@@ -102,6 +102,7 @@ public:
     virtual QFixed emSquareSize() const;
 
     virtual QFontEngine *cloneWithSize(qreal pixelSize) const;
+    virtual QFontEngine::Properties properties() const;
 
 private:
     friend class QRawFontPrivate;
diff --git src/gui/text/qfontengine_win.cpp src/gui/text/qfontengine_win.cpp
index 66a741c..5d0c209 100644
--- src/gui/text/qfontengine_win.cpp
+++ src/gui/text/qfontengine_win.cpp
@@ -190,9 +190,26 @@ static OUTLINETEXTMETRIC *getOutlineTextMetric(HDC hdc)
     return otm;
 }
 
+bool QFontEngineWin::hasCFFTable() const
+{
+    HDC hdc = shared_dc();
+    SelectObject(hdc, hfont);
+    return GetFontData(hdc, MAKE_TAG('C', 'F', 'F', ' '), 0, 0, 0) != GDI_ERROR;
+}
+
+bool QFontEngineWin::hasCMapTable() const
+{
+    HDC hdc = shared_dc();
+    SelectObject(hdc, hfont);
+    return GetFontData(hdc, MAKE_TAG('c', 'm', 'a', 'p'), 0, 0, 0) != GDI_ERROR;
+}
+
 void QFontEngineWin::getCMap()
 {
-    ttf = (bool)(tm.tmPitchAndFamily & TMPF_TRUETYPE);
+    ttf = (bool)(tm.tmPitchAndFamily & TMPF_TRUETYPE) || hasCMapTable();
+
+    cffTable = hasCFFTable();
+
     HDC hdc = shared_dc();
     SelectObject(hdc, hfont);
     bool symb = false;
@@ -279,7 +296,7 @@ int QFontEngineWin::getGlyphIndexes(const QChar *str, int numChars, QGlyphLayout
         if (symbol) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
-                glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, uc);
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
                 if(!glyphs->glyphs[glyph_pos] && uc < 0x100)
                     glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
             }
@@ -373,6 +390,7 @@ HGDIOBJ QFontEngineWin::selectDesignFont() const
 {
     LOGFONT f = logfont;
     f.lfHeight = unitsPerEm;
+    f.lfWidth = 0;
     HFONT designFont = CreateFontIndirect(&f);
     return SelectObject(shared_dc(), designFont);
 }
@@ -846,13 +864,34 @@ static bool addGlyphToPath(glyph_t glyph, const QFixedPoint &position, HDC hdc,
     mat.eM11.fract = mat.eM22.fract = 0;
     mat.eM21.value = mat.eM12.value = 0;
     mat.eM21.fract = mat.eM12.fract = 0;
+
+    GLYPHMETRICS gMetric;
+    memset(&gMetric, 0, sizeof(GLYPHMETRICS));
+
+#ifndef Q_OS_WINCE
+    if (metric) {
+        // If metrics requested, retrieve first using GGO_METRICS, because the returned
+        // values are incorrect for OpenType PS fonts if obtained at the same time as the
+        // glyph paths themselves (ie. with GGO_NATIVE as the format).
+        uint format = GGO_METRICS;
+        if (ttf)
+            format |= GGO_GLYPH_INDEX;
+        int res = GetGlyphOutline(hdc, glyph, format, &gMetric, 0, 0, &mat);
+        if (res == GDI_ERROR) {
+            return false;
+        }
+        // #### obey scale
+        *metric = glyph_metrics_t(gMetric.gmptGlyphOrigin.x, -gMetric.gmptGlyphOrigin.y,
+                                  (int)gMetric.gmBlackBoxX, (int)gMetric.gmBlackBoxY,
+                                  gMetric.gmCellIncX, gMetric.gmCellIncY);
+    }
+#endif
+
     uint glyphFormat = GGO_NATIVE;
 
     if (ttf)
         glyphFormat |= GGO_GLYPH_INDEX;
 
-    GLYPHMETRICS gMetric;
-    memset(&gMetric, 0, sizeof(GLYPHMETRICS));
     int bufferSize = GDI_ERROR;
 #if !defined(Q_WS_WINCE)
     bufferSize = GetGlyphOutline(hdc, glyph, glyphFormat, &gMetric, 0, 0, &mat);
@@ -871,12 +910,14 @@ static bool addGlyphToPath(glyph_t glyph, const QFixedPoint &position, HDC hdc,
         return false;
     }
 
-    if(metric) {
+#ifdef Q_OS_WINCE
+    if (metric) {
         // #### obey scale
         *metric = glyph_metrics_t(gMetric.gmptGlyphOrigin.x, -gMetric.gmptGlyphOrigin.y,
                                   (int)gMetric.gmBlackBoxX, (int)gMetric.gmBlackBoxY,
                                   gMetric.gmCellIncX, gMetric.gmCellIncY);
     }
+#endif
 
     int offset = 0;
     int headerOffset = 0;
@@ -1072,7 +1113,7 @@ void QFontEngineWin::getUnscaledGlyph(glyph_t glyph, QPainterPath *path, glyph_m
 
 bool QFontEngineWin::getSfntTableData(uint tag, uchar *buffer, uint *length) const
 {
-    if (!ttf)
+    if (!ttf && !cffTable)
         return false;
     HDC hdc = shared_dc();
     SelectObject(hdc, hfont);
diff --git src/gui/text/qfontengine_win_p.h src/gui/text/qfontengine_win_p.h
index 2b5ad4e..ba6aa02 100644
--- src/gui/text/qfontengine_win_p.h
+++ src/gui/text/qfontengine_win_p.h
@@ -126,6 +126,7 @@ public:
     uint        stockFont  : 1;
     uint        ttf        : 1;
     uint        hasOutline : 1;
+    uint        cffTable   : 1;
     TEXTMETRIC  tm;
     int         lw;
     const unsigned char *cmap;
@@ -145,6 +146,8 @@ public:
     mutable int designAdvancesSize;
 
 private:
+    bool hasCFFTable() const;
+    bool hasCMapTable() const;
     QNativeImage *drawGDIGlyph(HFONT font, glyph_t, int margin, const QTransform &xform,
                                QImage::Format mask_format);
 
diff --git src/svg/qsvggenerator.cpp src/svg/qsvggenerator.cpp
index 2d8fdcc..00d9b02 100644
--- src/svg/qsvggenerator.cpp
+++ src/svg/qsvggenerator.cpp
@@ -103,6 +103,7 @@ public:
 
         afterFirstUpdate = false;
         numGradients = 0;
+        clip = false;
     }
 
     QSize size;
@@ -129,6 +130,9 @@ public:
 
     QString currentGradientName;
     int numGradients;
+    QString stateString;
+    QString oldStateString;
+    bool clip;
 
     struct _attributes {
         QString document_title;
@@ -141,6 +145,18 @@ public:
         QString dashPattern, dashOffset;
         QString fill, fillOpacity;
     } attributes;
+
+    void emitState() {
+        if (stateString == oldStateString) return;
+
+        // close old state and start a new one...
+        if (afterFirstUpdate)
+            *stream << "</g>\n\n";
+        
+        *stream << stateString;
+        afterFirstUpdate = true;
+        oldStateString = stateString;
+    }
 };
 
 static inline QPaintEngine::PaintEngineFeatures svgEngineFeatures()
@@ -322,7 +338,7 @@ public:
     }
 
 
-    void qpenToSvg(const QPen &spen)
+    void qpenToSvg(const QPen &spen, QTextStream & s)
     {
         QString width;
 
@@ -330,7 +346,7 @@ public:
 
         switch (spen.style()) {
         case Qt::NoPen:
-            stream() << QLatin1String("stroke=\"none\" ");
+            s << QLatin1String("stroke=\"none\" ");
 
             d_func()->attributes.stroke = QLatin1String("none");
             d_func()->attributes.strokeOpacity = QString();
@@ -344,8 +360,8 @@ public:
             d_func()->attributes.stroke = color;
             d_func()->attributes.strokeOpacity = colorOpacity;
 
-            stream() << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
+            s << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
+            s << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
         }
             break;
         case Qt::DashLine:
@@ -368,10 +384,10 @@ public:
             d_func()->attributes.dashPattern = dashPattern;
             d_func()->attributes.dashOffset = dashOffset;
 
-            stream() << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-dasharray=\"")<<dashPattern<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-dashoffset=\"")<<dashOffset<< QLatin1String("\" ");
+            s << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
+            s << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
+            s << QLatin1String("stroke-dasharray=\"")<<dashPattern<< QLatin1String("\" ");
+            s << QLatin1String("stroke-dashoffset=\"")<<dashOffset<< QLatin1String("\" ");
             break;
         }
         default:
@@ -380,50 +396,50 @@ public:
         }
 
         if (spen.widthF() == 0)
-            stream() <<"stroke-width=\"1\" ";
+            s <<"stroke-width=\"1\" ";
         else
-            stream() <<"stroke-width=\"" << spen.widthF() << "\" ";
+            s <<"stroke-width=\"" << spen.widthF() << "\" ";
 
         switch (spen.capStyle()) {
         case Qt::FlatCap:
-            stream() << "stroke-linecap=\"butt\" ";
+            s << "stroke-linecap=\"butt\" ";
             break;
         case Qt::SquareCap:
-            stream() << "stroke-linecap=\"square\" ";
+            s << "stroke-linecap=\"square\" ";
             break;
         case Qt::RoundCap:
-            stream() << "stroke-linecap=\"round\" ";
+            s << "stroke-linecap=\"round\" ";
             break;
         default:
             qWarning("Unhandled cap style");
         }
         switch (spen.joinStyle()) {
         case Qt::MiterJoin:
-            stream() << "stroke-linejoin=\"miter\" "
+            s << "stroke-linejoin=\"miter\" "
                         "stroke-miterlimit=\""<<spen.miterLimit()<<"\" ";
             break;
         case Qt::BevelJoin:
-            stream() << "stroke-linejoin=\"bevel\" ";
+            s << "stroke-linejoin=\"bevel\" ";
             break;
         case Qt::RoundJoin:
-            stream() << "stroke-linejoin=\"round\" ";
+            s << "stroke-linejoin=\"round\" ";
             break;
         case Qt::SvgMiterJoin:
-            stream() << "stroke-linejoin=\"miter\" "
+            s << "stroke-linejoin=\"miter\" "
                         "stroke-miterlimit=\""<<spen.miterLimit()<<"\" ";
             break;
         default:
             qWarning("Unhandled join style");
         }
     }
-    void qbrushToSvg(const QBrush &sbrush)
+    void qbrushToSvg(const QBrush &sbrush, QTextStream & s)
     {
         d_func()->brush = sbrush;
         switch (sbrush.style()) {
         case Qt::SolidPattern: {
             QString color, colorOpacity;
             translate_color(sbrush.color(), &color, &colorOpacity);
-            stream() << "fill=\"" << color << "\" "
+            s << "fill=\"" << color << "\" "
                         "fill-opacity=\""
                      << colorOpacity << "\" ";
             d_func()->attributes.fill = color;
@@ -434,22 +450,22 @@ public:
             saveLinearGradientBrush(sbrush.gradient());
             d_func()->attributes.fill = QString::fromLatin1("url(#%1)").arg(d_func()->currentGradientName);
             d_func()->attributes.fillOpacity = QString();
-            stream() << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
+            s << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
             break;
         case Qt::RadialGradientPattern:
             saveRadialGradientBrush(sbrush.gradient());
             d_func()->attributes.fill = QString::fromLatin1("url(#%1)").arg(d_func()->currentGradientName);
             d_func()->attributes.fillOpacity = QString();
-            stream() << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
+            s << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
             break;
         case Qt::ConicalGradientPattern:
             saveConicalGradientBrush(sbrush.gradient());
             d_func()->attributes.fill = QString::fromLatin1("url(#%1)").arg(d_func()->currentGradientName);
             d_func()->attributes.fillOpacity = QString();
-            stream() << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
+            s << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
             break;
         case Qt::NoBrush:
-            stream() << QLatin1String("fill=\"none\" ");
+            s << QLatin1String("fill=\"none\" ");
             d_func()->attributes.fill = QLatin1String("none");
             d_func()->attributes.fillOpacity = QString();
             return;
@@ -458,7 +474,7 @@ public:
            break;
         }
     }
-    void qfontToSvg(const QFont &sfont)
+    void qfontToSvg(const QFont &sfont, QTextStream & s)
     {
         Q_D(QSvgPaintEngine);
 
@@ -488,12 +504,23 @@ public:
         d->attributes.font_family = d->font.family();
         d->attributes.font_style = d->font.italic() ? QLatin1String("italic") : QLatin1String("normal");
 
-        *d->stream << "font-family=\"" << d->attributes.font_family << "\" "
-                      "font-size=\"" << d->attributes.font_size << "\" "
-                      "font-weight=\"" << d->attributes.font_weight << "\" "
-                      "font-style=\"" << d->attributes.font_style << "\" "
-                   << endl;
+        s << "font-family=\"" << d->attributes.font_family << "\" "
+             "font-size=\"" << d->attributes.font_size << "\" "
+             "font-weight=\"" << d->attributes.font_weight << "\" "
+             "font-style=\"" << d->attributes.font_style << "\" "
+             << endl;
+    }
+
+    void setViewBoxClip(bool clip) {
+        Q_D(QSvgPaintEngine);
+        d->clip = clip;
     }
+    
+    bool viewBoxClip() const {
+        Q_D(const QSvgPaintEngine);
+        return d->clip;
+    }
+
 };
 
 class QSvgGeneratorPrivate
@@ -808,6 +835,27 @@ int QSvgGenerator::metric(QPaintDevice::PaintDeviceMetric metric) const
     return 0;
 }
 
+/*!
+    \property QSvgGenerator::resolution
+    \brief do not draw objects outside the viewBox
+    \since 4.7
+
+    When specified objects drawn compleatly outsite the viewBox
+    are not include in the output SVG.
+
+    \sa viewBox
+*/
+
+bool QSvgGenerator::viewBoxClip() const {
+    Q_D(const QSvgGenerator);
+    return d->engine->viewBoxClip();
+}
+
+void QSvgGenerator::setViewBoxClip(bool clip) {
+    Q_D(QSvgGenerator);
+    d->engine->setViewBoxClip(clip);
+}
+
 /*****************************************************************************
  * class QSvgPaintEngine
  */
@@ -908,10 +956,13 @@ void QSvgPaintEngine::drawImage(const QRectF &r, const QImage &image,
                                 const QRectF &sr,
                                 Qt::ImageConversionFlag flags)
 {
-    //Q_D(QSvgPaintEngine);
+    Q_D(QSvgPaintEngine);
 
     Q_UNUSED(sr);
     Q_UNUSED(flags);
+    if (d->clip && !d->matrix.mapRect(r).intersects(d->viewBox)) return;
+    d->emitState();
+
     stream() << "<image ";
     stream() << "x=\""<<r.x()<<"\" "
                 "y=\""<<r.y()<<"\" "
@@ -932,53 +983,35 @@ void QSvgPaintEngine::drawImage(const QRectF &r, const QImage &image,
 void QSvgPaintEngine::updateState(const QPaintEngineState &state)
 {
     Q_D(QSvgPaintEngine);
-    QPaintEngine::DirtyFlags flags = state.state();
-
-    // always stream full gstate, which is not required, but...
-    flags |= QPaintEngine::AllDirty;
-
-    // close old state and start a new one...
-    if (d->afterFirstUpdate)
-        *d->stream << "</g>\n\n";
-
-    *d->stream << "<g ";
 
-    if (flags & QPaintEngine::DirtyBrush) {
-        qbrushToSvg(state.brush());
-    }
-
-    if (flags & QPaintEngine::DirtyPen) {
-        qpenToSvg(state.pen());
-    }
-
-    if (flags & QPaintEngine::DirtyTransform) {
-        d->matrix = state.matrix();
-        *d->stream << "transform=\"matrix(" << d->matrix.m11() << ','
-                   << d->matrix.m12() << ','
-                   << d->matrix.m21() << ',' << d->matrix.m22() << ','
-                   << d->matrix.dx() << ',' << d->matrix.dy()
-                   << ")\""
-                   << endl;
-    }
-
-    if (flags & QPaintEngine::DirtyFont) {
-        qfontToSvg(state.font());
-    }
-
-    if (flags & QPaintEngine::DirtyOpacity) {
-        if (!qFuzzyIsNull(state.opacity() - 1))
-            stream() << "opacity=\""<<state.opacity()<<"\" ";
-    }
-
-    *d->stream << '>' << endl;
-
-    d->afterFirstUpdate = true;
+    d->stateString="";
+    QTextStream stateStream(&d->stateString);
+    stateStream << "<g ";
+    qbrushToSvg(state.brush(), stateStream);
+    qpenToSvg(state.pen(), stateStream);
+    
+    d->matrix = state.matrix();
+    stateStream << "transform=\"matrix(" << d->matrix.m11() << ','
+                << d->matrix.m12() << ','
+                << d->matrix.m21() << ',' << d->matrix.m22() << ','
+                << d->matrix.dx() << ',' << d->matrix.dy()
+                << ")\""
+                << endl;
+    qfontToSvg(state.font(), stateStream);
+    
+    if (!qFuzzyIsNull(state.opacity() - 1))
+        stateStream << "opacity=\""<<state.opacity()<<"\" ";
+    
+    stateStream << '>' << endl;
 }
 
 void QSvgPaintEngine::drawPath(const QPainterPath &p)
 {
     Q_D(QSvgPaintEngine);
 
+    if (d->clip && !d->matrix.mapRect(p.boundingRect()).intersects(d->viewBox)) return;
+    d->emitState();
+    
     *d->stream << "<path vector-effect=\""
                << (state->pen().isCosmetic() ? "non-scaling-stroke" : "none")
                << "\" fill-rule=\""
@@ -1024,12 +1057,15 @@ void QSvgPaintEngine::drawPolygon(const QPointF *points, int pointCount,
 {
     Q_ASSERT(pointCount >= 2);
 
-    //Q_D(QSvgPaintEngine);
+    Q_D(QSvgPaintEngine);
 
     QPainterPath path(points[0]);
     for (int i=1; i<pointCount; ++i)
         path.lineTo(points[i]);
 
+    if (d->clip && !d->matrix.mapRect(path.boundingRect()).intersects(d->viewBox)) return;
+    d->emitState();
+
     if (mode == PolylineMode) {
         stream() << "<polyline fill=\"none\" vector-effect=\""
                  << (state->pen().isCosmetic() ? "non-scaling-stroke" : "none")
@@ -1051,6 +1087,12 @@ void QSvgPaintEngine::drawTextItem(const QPointF &pt, const QTextItem &textItem)
     if (d->pen.style() == Qt::NoPen)
         return;
 
+    if (d->clip) {
+        QRectF b=painter()->boundingRect( QRectF(pt, QSize()) , Qt::AlignLeft, textItem.text());
+        if (!d->matrix.mapRect(b).intersects(d->viewBox)) return;
+    }
+    d->emitState();
+
     const QTextItemInt &ti = static_cast<const QTextItemInt &>(textItem);
     QString s = QString::fromRawData(ti.chars, ti.num_chars);
 
@@ -1060,7 +1102,7 @@ void QSvgPaintEngine::drawTextItem(const QPointF &pt, const QTextItem &textItem)
                   "stroke=\"none\" "
                   "xml:space=\"preserve\" "
                   "x=\"" << pt.x() << "\" y=\"" << pt.y() << "\" ";
-    qfontToSvg(textItem.font());
+    qfontToSvg(textItem.font(), *d->stream);
     *d->stream << " >"
                << Qt::escape(s)
                << "</text>"
diff --git src/svg/qsvggenerator.h src/svg/qsvggenerator.h
index d11a192..3818a84 100644
--- src/svg/qsvggenerator.h
+++ src/svg/qsvggenerator.h
@@ -96,6 +96,9 @@ public:
 
     void setResolution(int dpi);
     int resolution() const;
+
+    void setViewBoxClip(bool clip);
+    bool viewBoxClip() const;
 protected:
     QPaintEngine *paintEngine() const;
     int metric(QPaintDevice::PaintDeviceMetric metric) const;
diff --git tools/configure/configureapp.cpp tools/configure/configureapp.cpp
index 8546573..de0fad1 100644
--- tools/configure/configureapp.cpp
+++ tools/configure/configureapp.cpp
@@ -2394,9 +2394,9 @@ bool Configure::checkAvailability(const QString &part)
         available = qmakeSpec == "win32-msvc2005" || qmakeSpec == "win32-msvc2008" ||
                 qmakeSpec == "win32-msvc2010" || qmakeSpec == "win32-msvc2012" || qmakeSpec.startsWith("win32-g++");
         if (dictionary[ "SHARED" ] == "no") {
-            cout << endl << "WARNING: Using static linking will disable the WebKit module." << endl
-                 << endl;
-            available = false;
+           // cout << endl << "WARNING: Using static linking will disable the WebKit module." << endl
+           //      << endl;
+          //  available = false;
         }
     } else if (part == "AUDIO_BACKEND") {
         available = true;
